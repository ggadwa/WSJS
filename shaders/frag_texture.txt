uniform lowp sampler2D baseTex;
uniform lowp sampler2D normalTex;
uniform lowp sampler2D specularTex;
uniform lowp sampler2D lightmapTex;

uniform lowp vec3 ambient;
uniform mediump float shineFactor;

struct lightType {
    highp vec3 position;
    lowp vec3 color;
    mediump float intensity;
    mediump float invertIntensity;
    mediump float exponent;
};

uniform lightType light_0;
uniform lightType light_1;
uniform lightType light_2;
uniform lightType light_3;

varying highp vec3 eyeVector;
varying highp vec4 fragUV;

varying highp vec3 lightVector_0;
varying highp vec3 lightVertexVector_0;
varying highp vec3 lightVector_1;
varying highp vec3 lightVertexVector_1;
varying highp vec3 lightVector_2;
varying highp vec3 lightVertexVector_2;
//varying highp vec3 lightVector_3;
//varying highp vec3 lightVertexVector_3;

void main(void)
{
    highp float dist;
    lowp float att;

        // the ambient plus the
        // light map

    lowp vec3 pixelAmbient=texture2D(lightmapTex,fragUV.zw).rgb+ambient;

        // the texture fragment

    lowp vec4 tex=texture2D(baseTex,fragUV.xy);

        // the starting bump map
        // since it will be created by going through the
        // lights, we need a default value

    highp vec3 bumpLightVertexVector;
    lowp vec3 bumpMap=normalize((texture2D(normalTex,fragUV.xy).rgb*2.0)-1.0);
    lowp float bump=dot(vec3(0.33,0.33,0.33),bumpMap);

        // the starting spec map

    lowp vec3 spec=vec3(0.0,0.0,0.0),specHalfVector;
    lowp vec3 specMap=texture2D(specularTex,fragUV.xy).rgb;
    lowp float specFactor;

        // light 0

    dist=length(lightVector_0);

    if (dist<light_0.intensity) {

            // the lighting attenuation

        att=1.0-(dist*light_0.invertIntensity);
        att+=pow(att,light_0.exponent);
        pixelAmbient+=(light_0.color*att);

            // per-light bump calc

        bumpLightVertexVector=normalize(lightVertexVector_0);
        bump+=(dot(bumpLightVertexVector,bumpMap)*att);

            // per-light spec count

        specHalfVector=normalize(normalize(eyeVector)+bumpLightVertexVector);
        specFactor=max(dot(bumpMap,specHalfVector),0.0);
        spec+=((specMap*pow(specFactor,shineFactor))*att);
    }

        // light 1

    dist=length(lightVector_1);

    if (dist<light_1.intensity) {

            // the lighting attenuation

        att=1.0-(dist*light_1.invertIntensity);
        att+=pow(att,light_1.exponent);
        pixelAmbient+=(light_1.color*att);

            // per-light bump calc

        bumpLightVertexVector=normalize(lightVertexVector_1);
        bump+=(dot(bumpLightVertexVector,bumpMap)*att);

            // per-light spec count

        specHalfVector=normalize(normalize(eyeVector)+bumpLightVertexVector);
        specFactor=max(dot(bumpMap,specHalfVector),0.0);
        spec+=((specMap*pow(specFactor,shineFactor))*att);
    }

        // light 2

    dist=length(lightVector_2);

    if (dist<light_2.intensity) {

            // the lighting attenuation

        att=1.0-(dist*light_2.invertIntensity);
        att+=pow(att,light_2.exponent);
        pixelAmbient+=(light_2.color*att);

            // per-light bump calc

        bumpLightVertexVector=normalize(lightVertexVector_2);
        bump+=(dot(bumpLightVertexVector,bumpMap)*att);

            // per-light spec count

        specHalfVector=normalize(normalize(eyeVector)+bumpLightVertexVector);
        specFactor=max(dot(bumpMap,specHalfVector),0.0);
        spec+=((specMap*pow(specFactor,shineFactor))*att);
    }

        // light 3
/*
    dist=length(lightVector_3);

    if (dist<light_3.intensity) {

            // the lighting attenuation

        att=1.0-(dist*light_3.invertIntensity);
        att+=pow(att,light_3.exponent);
        pixelAmbient+=(light_3.color*att);

            // per-light bump calc

        bumpLightVertexVector=normalize(lightVertexVector_3);
        bump+=(dot(bumpLightVertexVector,bumpMap)*att);

            // per-light spec count

        specHalfVector=normalize(normalize(eyeVector)+bumpLightVertexVector);
        specFactor=max(dot(bumpMap,specHalfVector),0.0);
        spec+=((specMap*pow(specFactor,shineFactor))*att);
    }
*/
        // finish the spec by making sure
        // it's dimmed in dark areas
	
    spec=min(spec,1.0)*((pixelAmbient.r+pixelAmbient.g+pixelAmbient.b)*0.33);
	
        // add bump into the ambient and make
        // sure it's never less than 10% of the
        // ambient

    bump=max(bump,(((ambient.r+ambient.g+ambient.b)*0.33)*0.90));
    pixelAmbient*=bump;

        // finally create the pixel

    gl_FragColor.rgb=(tex.rgb*pixelAmbient)+spec;
    //gl_FragColor.rgb=texture2D(lightmapTex,fragUV.zw).rgb;//supergumba--testing light maps
    gl_FragColor.a=tex.a;
}
