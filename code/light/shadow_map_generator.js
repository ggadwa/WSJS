import PointClass from '../utility/point.js';import BoundClass from '../utility/bound.js';import ColorClass from '../utility/color.js';import Matrix4Class from '../utility/matrix4.js';import UploadClass from '../main/upload.js';//// shadowmap bitmap class// records each generated shadowmap// canvas and the last chunk written to//class ShadowmapBitmapClass{    constructor(shadowmapGenerator)    {        let n;                this.shadowmapGenerator=shadowmapGenerator;                    // some constants                this.shadowMapSize=shadowmapGenerator.SHADOWMAP_TEXTURE_SIZE;        this.chunkSize=shadowmapGenerator.SHADOWMAP_CHUNK_SIZE;        this.chunkPerRow=Math.trunc(shadowmapGenerator.SHADOWMAP_TEXTURE_SIZE/this.chunkSize);                    // the final bitmap                    this.canvas=null;        this.bitmap=null;            // the luminosity data        this.lumData=new Float32Array(shadowmapGenerator.SHADOWMAP_TEXTURE_SIZE*shadowmapGenerator.SHADOWMAP_TEXTURE_SIZE);            // clear to min shadow color        for (n=0;n!==(shadowmapGenerator.SHADOWMAP_TEXTURE_SIZE*shadowmapGenerator.SHADOWMAP_TEXTURE_SIZE);n++) {            this.lumData[n]=shadowmapGenerator.SHADOW_MIN_VALUE;        }            // chunk 0 is the all black chunk,            // chunk 1 is the all white chunk                    this.fillChunk(0,shadowmapGenerator.SHADOW_MIN_VALUE);        this.fillChunk(1,1.0);                        // so first free chunk is 2                    this.chunkIdx=2;                Object.seal(this);    }            //        // chunk utilities        //            getChunkDrawCoordinates(cIdx,p0,p1,p2)    {        let x,y;        let secondTrig;                secondTrig=cIdx%2;        cIdx=cIdx>>1;                x=(cIdx%this.chunkPerRow)*this.chunkSize;        y=Math.trunc(cIdx/this.chunkPerRow)*this.chunkSize;                if (!secondTrig) {            p0.setFromValues(x,y,0);            p1.setFromValues((x+this.chunkSize),y,0);            p2.setFromValues(x,(y+this.chunkSize),0);        }        else {            p0.setFromValues((x+this.chunkSize),y,0);            p1.setFromValues((x+this.chunkSize),(y+this.chunkSize),0);            p2.setFromValues(x,(y+this.chunkSize),0);        }    }        getChunkUVCoordinatesReduceVertex(pnt,cx,cy,factor)    {        let dx,dy,dist;        let nx,ny;                    // get the distance to the center                    dx=pnt.x-cx;        dy=pnt.y-cy;                    // make it a normal                dist=Math.sqrt((dx*dx)+(dy*dy));        if (dist===0) return;                nx=dx/dist;        ny=dy/dist;                    // now calculate the shrunk version                    dist=dist*factor;        pnt.x=cx+Math.trunc(nx*dist);        pnt.y=cy+Math.trunc(ny*dist);    }        getChunkUVCoordinates(cIdx,p0,p1,p2)    {        let cx,cy;        let uvReduce=0.95;                    // get the draw coordinates                    this.getChunkDrawCoordinates(cIdx,p0,p1,p2);                    // and reduce                    cx=Math.trunc((p0.x+p1.x+p2.x)/3);        cy=Math.trunc((p0.y+p1.y+p2.y)/3);                this.getChunkUVCoordinatesReduceVertex(p0,cx,cy,uvReduce);        this.getChunkUVCoordinatesReduceVertex(p1,cx,cy,uvReduce);        this.getChunkUVCoordinatesReduceVertex(p2,cx,cy,uvReduce);    }        fillChunk(cIdx,lum)    {        let pIdx;        let x,y,ty,by,lx,rx,tlx,blx,trx,brx;        let p0=new PointClass(0,0,0);        let p1=new PointClass(0,0,0);        let p2=new PointClass(0,0,0);                this.getChunkDrawCoordinates(cIdx,p0,p1,p2);                if (p0.y===p1.y) {            ty=p0.y;            by=p2.y;                        tlx=blx=p0.x;            trx=p1.x;            brx=p2.x;        }        else {            ty=p0.y;            by=p1.y;                        tlx=p0.x;            blx=p2.x;            trx=brx=p0.x;        }                for (y=ty;y<by;y++) {            lx=tlx+Math.trunc(((blx-tlx)*(y-ty))/(by-ty));            rx=trx+Math.trunc(((brx-trx)*(y-ty))/(by-ty));                        pIdx=(y*this.shadowMapSize)+lx;                            for (x=lx;x<rx;x++) {                this.lumData[pIdx++]=lum;            }        }    }            //        // create a bitmap from the data        //    finish()    {        let n;        let ctx;        let imgData,pIdx,pixel;                this.canvas=document.createElement('canvas');        this.canvas.width=this.shadowMapSize;        this.canvas.height=this.shadowMapSize;                ctx=this.canvas.getContext('2d');        imgData=ctx.getImageData(0,0,this.shadowMapSize,this.shadowMapSize);                pIdx=0;                for (n=0;n!==(this.shadowMapSize*this.shadowMapSize);n++) {            pixel=this.lumData[n]*255.0;            imgData.data[pIdx++]=pixel;            imgData.data[pIdx++]=pixel;            imgData.data[pIdx++]=pixel;            imgData.data[pIdx++]=255;        }                this.canvas.getContext('2d').putImageData(imgData,0,0);    }}//// this object contains one of the lights in the scene,// plus a list of all it's collision meshes to speed// up the tracing//class ShadowmapLightClass{    constructor(core,mapLight)    {        this.core=core;        this.position=mapLight.position;        this.intensity=mapLight.intensity;        this.invertIntensity=mapLight.invertIntensity;        this.exponent=mapLight.exponent;                    // some ray trace optimization values                    this.lastBlockMeshIdx=-1;        this.lastBlockTriangleIdx=-1;            // all the meshes that collide with            // the light globe                    this.collideMeshes=[];    }        calculateCollisionList()    {        let n,mesh;        let pnt=new PointClass(0,0,0);        let map=this.core.map;                for (n=0;n!==map.meshList.meshes.length;n++) {            mesh=map.meshList.meshes[n];                            // check if center in light globe                            if (mesh.center.distance(this.position)<this.intensity) {                this.collideMeshes.push(n);                continue;            }                            // now the 8 cube corners                        pnt.setFromValues(mesh.xBound.min,mesh.yBound.min,mesh.zBound.min);            if (pnt.distance(this.position)<this.intensity) {                this.collideMeshes.push(n);                continue;            }            pnt.setFromValues(mesh.xBound.min,mesh.yBound.min,mesh.zBound.max);            if (pnt.distance(this.position)<this.intensity) {                this.collideMeshes.push(n);                continue;            }            pnt.setFromValues(mesh.xBound.max,mesh.yBound.min,mesh.zBound.min);            if (pnt.distance(this.position)<this.intensity) {                this.collideMeshes.push(n);                continue;            }            pnt.setFromValues(mesh.xBound.max,mesh.yBound.min,mesh.zBound.max);            if (pnt.distance(this.position)<this.intensity) {                this.collideMeshes.push(n);                continue;            }                        pnt.setFromValues(mesh.xBound.min,mesh.yBound.max,mesh.zBound.min);            if (pnt.distance(this.position)<this.intensity) {                this.collideMeshes.push(n);                continue;            }            pnt.setFromValues(mesh.xBound.min,mesh.yBound.max,mesh.zBound.max);            if (pnt.distance(this.position)<this.intensity) {                this.collideMeshes.push(n);                continue;            }            pnt.setFromValues(mesh.xBound.max,mesh.yBound.max,mesh.zBound.min);            if (pnt.distance(this.position)<this.intensity) {                this.collideMeshes.push(n);                continue;            }            pnt.setFromValues(mesh.xBound.max,mesh.yBound.max,mesh.zBound.max);            if (pnt.distance(this.position)<this.intensity) {                this.collideMeshes.push(n);                continue;            }        }    }}//// generate shadow map class//export default class ShadowmapGeneratorClass{    constructor(core,dialog,callbackFunc)    {        this.core=core;        this.dialog=dialog;        this.callbackFunc=callbackFunc;                this.debugTimestamp=0;                    // constants                    this.SHADOWMAP_TEXTURE_SIZE=1024;        this.SHADOWMAP_CHUNK_SPLIT=16;                  // how many chunks in both the X and Y direction        this.SHADOWMAP_CHUNK_SIZE=Math.trunc(this.SHADOWMAP_TEXTURE_SIZE/this.SHADOWMAP_CHUNK_SPLIT);    // square pixel size of chunks        this.SHADOWMAP_CHUNK_PER_TEXTURE=(this.SHADOWMAP_CHUNK_SPLIT*this.SHADOWMAP_CHUNK_SPLIT)*2;        // how many chunks in a single texture        this.SHADOW_MIN_VALUE=0.3;                this.RENDER_NORMAL=0;        this.RENDER_ALL_BLACK=1;        this.RENDER_ALL_WHITE=2;            // array of bitmaps that make up the shadowmaps            // each is an object with a canvas and the last chunk            // drawn to (the chunkIdx)        this.shadowmapList=[];                    // to track which shadowmap each mesh is in                    this.meshShadowMapIndex=new Int16Array(this.core.map.meshList.meshes.length);            // lights in ray trace                    this.lights=[];            // some pre-allocates                    this.lightVector=new PointClass(0,0,0);        this.lightVectorNormal=new PointClass(0,0,0);                this.lightBoundX=new BoundClass(0,0);        this.lightBoundY=new BoundClass(0,0);        this.lightBoundZ=new BoundClass(0,0);                    this.v0=new PointClass(0,0,0);      // the 3D triangle in the map        this.v1=new PointClass(0,0,0);        this.v2=new PointClass(0,0,0);                this.normal=new PointClass(0,0,0);  // a single normal to eliminate lights                this.t0=new PointClass(0,0,0);      // the 2D shadow map projection        this.t1=new PointClass(0,0,0);        this.t2=new PointClass(0,0,0);                this.mat2d=new Matrix4Class();      // these are used to create a transformation matrix from 2D render to 3D triangle        this.mat2dInvert=new Matrix4Class();        this.mat3d=new Matrix4Class();        this.transformMat=new Matrix4Class();                this.rayPoint=new PointClass(0,0,0);        this.rayTraceVertexColor=new ColorClass(0,0,0);                this.v10=new PointClass(0,0,0);        this.v20=new PointClass(0,0,0);                this.tt0=new PointClass(0,0,0);        this.tt1=new PointClass(0,0,0);        this.tt2=new PointClass(0,0,0);                Object.seal(this);    }        getMeshTriangleVertexes(mesh,tIdx,v0,v1,v2,normal)    {        let vIdx;                tIdx*=3;        vIdx=mesh.indexArray[tIdx]*3;        v0.setFromValues(mesh.vertexArray[vIdx],mesh.vertexArray[vIdx+1],mesh.vertexArray[vIdx+2]);        if (normal!==null) normal.setFromValues(mesh.normalArray[vIdx],mesh.normalArray[vIdx+1],mesh.normalArray[vIdx+2]);                vIdx=mesh.indexArray[tIdx+1]*3;        v1.setFromValues(mesh.vertexArray[vIdx],mesh.vertexArray[vIdx+1],mesh.vertexArray[vIdx+2]);                vIdx=mesh.indexArray[tIdx+2]*3;        v2.setFromValues(mesh.vertexArray[vIdx],mesh.vertexArray[vIdx+1],mesh.vertexArray[vIdx+2]);    }            //        // ray tracing        //    rayTraceTriangle(vrt,vct,t0,t1,t2)    {        let perpVectorX,perpVectorY,perpVectorZ;        let det,invDet,u,v;        let lineToTrigPointVectorX,lineToTrigPointVectorY,lineToTrigPointVectorZ;        let lineToTrigPerpVectorX,lineToTrigPerpVectorY,lineToTrigPerpVectorZ;                    // vrt = point to ray trace            // v10[x,y,z]=t1[x,y,z]-t0[x,y,z]            // v20[x,y,z]=t2[x,y,z]-t0[x,y,z]                this.v10.setFromSubPoint(t1,t0);        this.v20.setFromSubPoint(t2,t0);            // calculate the determinate            // perpVector is cross(vector,v2)            // det is dot(v1,perpVector)        perpVectorX=(vct.y*this.v20.z)-(vct.z*this.v20.y);        perpVectorY=(vct.z*this.v20.x)-(vct.x*this.v20.z);        perpVectorZ=(vct.x*this.v20.y)-(vct.y*this.v20.x);        det=(this.v10.x*perpVectorX)+(this.v10.y*perpVectorY)+(this.v10.z*perpVectorZ);            // is line on the same plane as triangle?        if ((det>-0.00001) && (det<0.00001)) return(false);            // get the inverse determinate        invDet=1.0/det;            // calculate triangle U and test            // lineToTrigPointVector is vector from vertex to triangle point 0            // u is invDet * dot(lineToTrigPointVector,perpVector)        lineToTrigPointVectorX=vrt.x-t0.x;        lineToTrigPointVectorY=vrt.y-t0.y;        lineToTrigPointVectorZ=vrt.z-t0.z;        u=invDet*((lineToTrigPointVectorX*perpVectorX)+(lineToTrigPointVectorY*perpVectorY)+(lineToTrigPointVectorZ*perpVectorZ));        if ((u<0.0) || (u>1.0)) return(false);            // calculate triangle V and test            // lineToTrigPerpVector is cross(lineToTrigPointVector,v1)            // v is invDet * dot(vector,lineToTrigPerpVector)        lineToTrigPerpVectorX=(lineToTrigPointVectorY*this.v10.z)-(lineToTrigPointVectorZ*this.v10.y);        lineToTrigPerpVectorY=(lineToTrigPointVectorZ*this.v10.x)-(lineToTrigPointVectorX*this.v10.z);        lineToTrigPerpVectorZ=(lineToTrigPointVectorX*this.v10.y)-(lineToTrigPointVectorY*this.v10.x);        v=invDet*((vct.x*lineToTrigPerpVectorX)+(vct.y*lineToTrigPerpVectorY)+(vct.z*lineToTrigPerpVectorZ));        if ((v<0.0) || ((u+v)>1.0)) return(false);            // t is the point on the line, from the            // invDet*dot(v2,lineToTrigPerpVector)            // this is a little different then normal ray trace            // hits, we add in an extra 0.01 slop so polygons that are            // touching each other don't have edges grayed in        let t=invDet*((this.v20.x*lineToTrigPerpVectorX)+(this.v20.y*lineToTrigPerpVectorY)+(this.v20.z*lineToTrigPerpVectorZ));        return((t>0.01)&&(t<1.0));    }    rayTraceMap(lightList,vrt)    {        let n,nLight,trigCount;        let light;        let k,p,hit,mesh,nMesh;        let dist;        let map=this.core.map;                    // we use the passed in light list which is a cut down            // list precalculcated from mesh/light interactions and            // removing any lights that are facing away from the            // front side of the triangle        nLight=lightList.length;        for (n=0;n!==nLight;n++) {            light=lightList[n];                // light within light range?            dist=light.position.distance(vrt);            if (dist>light.intensity) continue;                // vector from render point to light            this.lightVector.setFromSubPoint(light.position,vrt);                // we keep a list of the last mesh                // to block a light and we check that first                // because a lot of the time the same mesh will come                // up rendering a triangle in a mesh               if (light.lastBlockMeshIdx!==-1) {                mesh=map.meshList.meshes[light.lastBlockMeshIdx];                                this.getMeshTriangleVertexes(mesh,light.lastBlockTriangleIdx,this.tt0,this.tt1,this.tt2,null);                if (this.rayTraceTriangle(vrt,this.lightVector,this.tt0,this.tt1,this.tt2)) continue;            }                // light bounding            this.lightBoundX.setFromValues(vrt.x,light.position.x);            this.lightBoundY.setFromValues(vrt.y,light.position.y);            this.lightBoundZ.setFromValues(vrt.z,light.position.z);                // any hits?                // only run through the meshes that collide with                // the light globe because only they can block            hit=false;            nMesh=light.collideMeshes.length;            for (k=0;k!==nMesh;k++) {                mesh=map.meshList.meshes[light.collideMeshes[k]];                                    // hand inlined this from mesh.boxBoundCollision                    // do x/z first because of more x/z nature of maps as                    // this should be the earliest eliminations                                    if ((mesh.xBound.min>=this.lightBoundX.max) || (mesh.xBound.max<=this.lightBoundX.min)) continue;                if ((mesh.zBound.min>=this.lightBoundZ.max) || (mesh.zBound.max<=this.lightBoundZ.min)) continue;                if ((mesh.yBound.min>=this.lightBoundY.max) || (mesh.yBound.max<=this.lightBoundY.min)) continue;                    // do all the trigs                                    trigCount=mesh.trigCount;                for (p=0;p!==trigCount;p++) {                    this.getMeshTriangleVertexes(mesh,p,this.tt0,this.tt1,this.tt2,null);                                        if (this.rayTraceTriangle(vrt,this.lightVector,this.tt0,this.tt1,this.tt2)) {                        hit=true;                        light.lastBlockMeshIdx=light.collideMeshes[k];                        light.lastBlockTriangleIdx=p;                        break;                    }                }                if (hit) break;            }                            // at least one light got through, not in shadow                            if (!hit) return(true);        }                return(false);    }            //        // render shadowmap for mesh and triangle        //    renderTriangle(shadowmap,meshIdx,v0,v1,v2,normal,t0,t1,t2)    {        let n,x,y,lx,rx,ty,by,pIdx;        let tlx,blx,trx,brx;        let dist,allBlack,allWhite;        let light,lightList;        let lumData=shadowmap.lumData;                    // create a light list to check the            // triangle against                lightList=[];        for (n=0;n!==this.lights.length;n++) {            light=this.lights[n];                            // only consider a light if it collides                // with this mesh                            if (light.collideMeshes.indexOf(meshIdx)===-1) continue;                            // eliminate for distance                            dist=light.position.distance(v0);            if (dist>light.intensity) continue;                // check all the vertex normals                // only eliminate if all vertexes are                // behind              this.lightVectorNormal.setFromValues((light.position.x-v0.x),(light.position.y-v0.y),(light.position.z-v0.z));            this.lightVectorNormal.normalize();            if (this.lightVectorNormal.dot(normal)>=0.0) {                lightList.push(light);                continue;            }                        this.lightVectorNormal.setFromValues((light.position.x-v1.x),(light.position.y-v1.y),(light.position.z-v1.z));            this.lightVectorNormal.normalize();            if (this.lightVectorNormal.dot(normal)>=0.0) {                lightList.push(light);                continue;            }                        this.lightVectorNormal.setFromValues((light.position.x-v2.x),(light.position.y-v2.y),(light.position.z-v2.z));            this.lightVectorNormal.normalize();            if (this.lightVectorNormal.dot(normal)>=0.0) {                lightList.push(light);                continue;            }        }                    // if no lights, it's all black                    if (lightList.length===0) return(this.RENDER_ALL_BLACK);                    // flag to see if we only wrote black or white lum values                    allBlack=true;        allWhite=true;                    // create a transformation matrix to get            // the 2d triangle to the 3d one            // the transform matrix is [3d points]*invert([2d point (z=0)])                    this.mat2d.fromArray([t0.x,t0.y,0,1,t1.x,t1.y,0,1,t2.x,t2.y,0,1,1,1,1,1]);        this.mat2dInvert.setFromInvertMatrix(this.mat2d);        this.mat3d.fromArray([v0.x,v0.y,v0.z,1,v1.x,v1.y,v1.z,1,v2.x,v2.y,v2.z,1,1,1,1,1]);        this.transformMat.setFromMultiply(this.mat3d,this.mat2dInvert);                    // render the triangle                    if (t0.y===t1.y) {            ty=t0.y;            by=t2.y;                        tlx=blx=t0.x;            trx=t1.x;            brx=t2.x;        }        else {            ty=t0.y;            by=t1.y;                        tlx=t0.x;            blx=t2.x;            trx=brx=t0.x;        }                for (y=ty;y<by;y++) {            lx=tlx+Math.trunc(((blx-tlx)*(y-ty))/(by-ty));            rx=trx+Math.trunc(((brx-trx)*(y-ty))/(by-ty));                        pIdx=(y*this.SHADOWMAP_TEXTURE_SIZE)+lx;                            for (x=lx;x<rx;x++) {                            // ray trace the 3d pixel                                this.rayPoint.setFromValues(x,y,0);                    this.rayPoint.matrixMultiply(this.transformMat);                                if (this.rayTraceMap(lightList,this.rayPoint)) {                    lumData[pIdx]=1.0;                    allBlack=false;                }                else {                    allWhite=false; // shadow lum already in pixel                }                                pIdx++;            }        }                if (allBlack) return(this.RENDER_ALL_BLACK);        if (allWhite) return(this.RENDER_ALL_WHITE);        return(this.RENDER_NORMAL);    }    renderMesh(meshIdx)    {        let n,renderResult,shadowmapIdx;        let vertexShadowArray,uvShadowArray;        let mesh,shadowmap;        let map=this.core.map;                mesh=map.meshList.meshes[meshIdx];                this.dialog.updateProgress((1+(97*(meshIdx/map.meshList.meshes.length))),('Mesh '+meshIdx+'/'+map.meshList.meshes.length));                    // we use regular arrays so we            // can do push, converting them to            // floats at the end                    vertexShadowArray=[];        uvShadowArray=[];                    // we want to put the entire mesh into            // one shadowmap, so find a shadow map that            // has the room        shadowmapIdx=-1;        for (n=0;n!==this.shadowmapList.length;n++) {            if ((this.SHADOWMAP_CHUNK_PER_TEXTURE-this.shadowmapList[n].chunkIdx)>mesh.trigCount) {                shadowmapIdx=n;                break;            }        }            // if we didn't find a shadowmap, make a new one        if (shadowmapIdx===-1) {            shadowmapIdx=this.shadowmapList.length;            this.shadowmapList.push(new ShadowmapBitmapClass(this));        }                    // run through the triangles            // if no lights hit a triangle, it's            // autoset to chunk 0, the all black trig                    shadowmap=this.shadowmapList[shadowmapIdx];                for (n=0;n!==mesh.trigCount;n++) {                            // get vertexes for the 3D world triangle                // and a single normal                            this.getMeshTriangleVertexes(mesh,n,this.v0,this.v1,this.v2,this.normal);                // and the vertexes for the 2D chunk shadowmap            shadowmap.getChunkDrawCoordinates(shadowmap.chunkIdx,this.t0,this.t1,this.t2);                            // render the triangle                            renderResult=this.renderTriangle(shadowmap,meshIdx,this.v0,this.v1,this.v2,this.normal,this.t0,this.t1,this.t2);                            // advance chunk if not all black/white (which means                // we used a chunk instead of the default all black/white chunk                        switch (renderResult) {                case this.RENDER_ALL_BLACK:                    shadowmap.getChunkUVCoordinates(0,this.t0,this.t1,this.t2);                    break;                case this.RENDER_ALL_WHITE:                    shadowmap.getChunkUVCoordinates(1,this.t0,this.t1,this.t2);                    break;                default:                    shadowmap.getChunkUVCoordinates(shadowmap.chunkIdx,this.t0,this.t1,this.t2);                    shadowmap.chunkIdx++;                    break;            }                            // add the shadow map pass triangle                            vertexShadowArray.push(this.v0.x,this.v0.y,this.v0.z);            uvShadowArray.push((this.t0.x/this.SHADOWMAP_TEXTURE_SIZE),(this.t0.y/this.SHADOWMAP_TEXTURE_SIZE));                    vertexShadowArray.push(this.v1.x,this.v1.y,this.v1.z);            uvShadowArray.push((this.t1.x/this.SHADOWMAP_TEXTURE_SIZE),(this.t1.y/this.SHADOWMAP_TEXTURE_SIZE));                    vertexShadowArray.push(this.v2.x,this.v2.y,this.v2.z);            uvShadowArray.push((this.t2.x/this.SHADOWMAP_TEXTURE_SIZE),(this.t2.y/this.SHADOWMAP_TEXTURE_SIZE));        }                    // now add the vertex and uvs                    mesh.vertexShadowArray=new Float32Array(vertexShadowArray);        mesh.uvShadowArray=new Float32Array(uvShadowArray);            // map meshes have a temporary index for            // the light map.  we don't create the light            // maps into the very end (as they can be shared)            // so this is used for tracking it until than                    this.meshShadowMapIndex[meshIdx]=shadowmapIdx;            // move on to next mesh            // if out of mesh, finish up creation        meshIdx++;        if (meshIdx>=this.core.map.meshList.meshes.length) {            setTimeout(this.createFinish.bind(this),1);            return;        }            // next mesh        setTimeout(this.renderMesh.bind(this,meshIdx),1);    }            //        // build shadowmap model bin        // mesh count (int)        //   bitmap index (int)        //   vertex byte count (int)        //   uv byte count (int)        //   vertexes (array of 3 floats)        //   uvs (array of 2 floats)        //            buildShadowMapModelBin()    {        let n,k,len,offset,mesh;        let data,dataView;        let byteBuffer,str;        let map=this.core.map;        let nMesh=map.meshList.meshes.length;                    // calculate the length                    len=4;      // mesh count                for (n=0;n!=nMesh;n++) {            mesh=map.meshList.meshes[n];                        len+=12;        // bitmap index and vertex/uv byte count            len+=((mesh.vertexShadowArray.length*4)+(mesh.uvShadowArray.length*4)); // vertex and UVs        }                    // fill the data                    data=new ArrayBuffer(len);                dataView=new DataView(data,0,len);                dataView.setInt32(0,nMesh);                offset=4;                for (n=0;n!=nMesh;n++) {            mesh=map.meshList.meshes[n];                        dataView.setInt32(offset,this.meshShadowMapIndex[n]);            offset+=4;            dataView.setInt32(offset,mesh.vertexShadowArray.length);            offset+=4;            dataView.setInt32(offset,mesh.uvShadowArray.length);            offset+=4;                        for (k=0;k!==mesh.vertexShadowArray.length;k++) {                dataView.setFloat32(offset,mesh.vertexShadowArray[k]);                offset+=4;            }            for (k=0;k!==mesh.uvShadowArray.length;k++) {                dataView.setFloat32(offset,mesh.uvShadowArray[k]);                offset+=4;            }           }                    // now do the base64 conversion                    byteBuffer=new Uint8Array(data);        str='';                for (n=0;n!==byteBuffer.byteLength;n++) {            str+=String.fromCharCode(byteBuffer[n]);        }                return(btoa(str));    }            //        // create shadowmaps        // creation has to be done by a timer because this        // is too slow and browsers will bounce the script        //    create()    {        let n,light,effect;        let map=this.core.map;                this.debugTimestamp=Date.now();                this.dialog.updateProgress(1,'Setting Up');                    // build a list of lights for the            // scene that have mesh collisions                    this.lights=[];                for (n=0;n!==map.lightList.lights.length;n++) {            light=new ShadowmapLightClass(this.core,map.lightList.lights[n]);            light.calculateCollisionList();            this.lights.push(light);        }                for (n=0;n!==map.effectList.effects.length;n++) {            effect=map.effectList.effects[n];            if (effect.light===null) continue;                        light=new ShadowmapLightClass(this.core,effect.light);            light.calculateCollisionList();            this.lights.push(light);        }            // run through the meshes            // on a timer        setTimeout(this.renderMesh.bind(this,0),1);    }    async createFinish()    {        let n;        let upload,fileName,data;                this.dialog.updateProgress(99,'Uploading');                    // make canvases for all the shadowmaps                    for (n=0;n!==this.shadowmapList.length;n++) {            this.shadowmapList[n].finish();        }            // upload the data                    upload=new UploadClass(this.core);                    // shadow maps as pngs                for (n=0;n!==this.shadowmapList.length;n++) {            fileName='shadowmap_'+n+'.png';            data=this.shadowmapList[n].canvas.toDataURL();            data=data.substring(data.indexOf(',')+1);            upload.upload(fileName,data);   // already in base64        }                    // the data                    data=this.buildShadowMapModelBin(); // returns base64        upload.upload('shadowmap.bin',data);        //this.debugShadowmapBitmap(this.shadowmapList[0]);                console.info('time='+(Date.now()-this.debugTimestamp));            // finish with the callback        this.callbackFunc();    }            //        // quick debugging function        //            debugShadowmapBitmap(shadowmapBitmap)    {        let n,pIdx,pixel;        let debugCanvas,ctx;        let imgData;                debugCanvas=document.createElement('canvas');        debugCanvas.style.position='absolute';        debugCanvas.style.left='0px';        debugCanvas.style.top='0px';        debugCanvas.style.zIndex=1000;        debugCanvas.style.touchAction='none';        debugCanvas.width=this.SHADOWMAP_TEXTURE_SIZE;        debugCanvas.height=this.SHADOWMAP_TEXTURE_SIZE;        document.body.appendChild(debugCanvas);                ctx=debugCanvas.getContext('2d');        imgData=ctx.getImageData(0,0,this.SHADOWMAP_TEXTURE_SIZE,this.SHADOWMAP_TEXTURE_SIZE);                pIdx=0;                for (n=0;n!==(this.SHADOWMAP_TEXTURE_SIZE*this.SHADOWMAP_TEXTURE_SIZE);n++) {            pixel=shadowmapBitmap.lumData[n]*255.0;            imgData.data[pIdx++]=pixel;            imgData.data[pIdx++]=pixel;            imgData.data[pIdx++]=pixel;            imgData.data[pIdx++]=255;        }                debugCanvas.getContext('2d').putImageData(imgData,0,0);    }}