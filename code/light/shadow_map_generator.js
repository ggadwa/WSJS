import PointClass from '../utility/point.js';import BoundClass from '../utility/bound.js';import ColorClass from '../utility/color.js';import Matrix4Class from '../utility/matrix4.js';import UploadClass from '../main/upload.js';//// shadowmap bitmap class// records each generated shadowmap// canvas and the last chunk written to//class ShadowmapBitmapClass{    constructor(shadowmapGenerator)    {        let n;                this.shadowmapGenerator=shadowmapGenerator;                    // some constants                this.shadowMapSize=shadowmapGenerator.SHADOWMAP_TEXTURE_SIZE;        this.chunkSize=shadowmapGenerator.SHADOWMAP_CHUNK_SIZE;        this.chunkPerRow=Math.trunc(shadowmapGenerator.SHADOWMAP_TEXTURE_SIZE/this.chunkSize);                    // the final bitmap                    this.canvas=null;        this.bitmap=null;            // the luminosity data        this.lumData=new Float32Array(shadowmapGenerator.SHADOWMAP_TEXTURE_SIZE*shadowmapGenerator.SHADOWMAP_TEXTURE_SIZE);            // clear to min shadow color        for (n=0;n!==(shadowmapGenerator.SHADOWMAP_TEXTURE_SIZE*shadowmapGenerator.SHADOWMAP_TEXTURE_SIZE);n++) {            this.lumData[n]=shadowmapGenerator.SHADOW_MIN_VALUE;        }            // chunk 0 is the all black chunk,                    this.fillChunk(0,shadowmapGenerator.SHADOW_MIN_VALUE);                        // so first free chunk is 1                    this.chunkIdx=1;                Object.seal(this);    }            //        // chunk utilities        //            getChunkDrawCoordinates(cIdx,p0,p1,p2)    {        let x,y;        let secondTrig;                secondTrig=cIdx%2;        cIdx=cIdx>>1;                x=(cIdx%this.chunkPerRow)*this.chunkSize;        y=Math.trunc(cIdx/this.chunkPerRow)*this.chunkSize;                if (!secondTrig) {            p0.setFromValues(x,y,0);            p1.setFromValues((x+this.chunkSize),y,0);            p2.setFromValues(x,(y+this.chunkSize),0);        }        else {            p0.setFromValues((x+this.chunkSize),y,0);            p1.setFromValues((x+this.chunkSize),(y+this.chunkSize),0);            p2.setFromValues(x,(y+this.chunkSize),0);        }    }        getChunkUVCoordinatesReduceVertex(pnt,cx,cy,factor)    {        let dx,dy,dist;        let nx,ny;                    // get the distance to the center                    dx=pnt.x-cx;        dy=pnt.y-cy;                    // make it a normal                dist=Math.sqrt((dx*dx)+(dy*dy));        if (dist===0) return;                nx=dx/dist;        ny=dy/dist;                    // now calculate the shrunk version                    dist=dist*factor;        pnt.x=cx+Math.trunc(nx*dist);        pnt.y=cy+Math.trunc(ny*dist);    }        getChunkUVCoordinates(cIdx,p0,p1,p2)    {        let cx,cy;        let uvReduce=0.95;                    // get the draw coordinates                    this.getChunkDrawCoordinates(cIdx,p0,p1,p2);                    // and reduce                    cx=Math.trunc((p0.x+p1.x+p2.x)/3);        cy=Math.trunc((p0.y+p1.y+p2.y)/3);                this.getChunkUVCoordinatesReduceVertex(p0,cx,cy,uvReduce);        this.getChunkUVCoordinatesReduceVertex(p1,cx,cy,uvReduce);        this.getChunkUVCoordinatesReduceVertex(p2,cx,cy,uvReduce);    }        fillChunk(cIdx,lum)    {        let pIdx;        let x,y,ty,by,lx,rx,tlx,blx,trx,brx;        let p0=new PointClass(0,0,0);        let p1=new PointClass(0,0,0);        let p2=new PointClass(0,0,0);                this.getChunkDrawCoordinates(cIdx,p0,p1,p2);                if (p0.y===p1.y) {            ty=p0.y;            by=p2.y;                        tlx=blx=p0.x;            trx=p1.x;            brx=p2.x;        }        else {            ty=p0.y;            by=p1.y;                        tlx=p0.x;            blx=p2.x;            trx=brx=p0.x;        }                for (y=ty;y<by;y++) {            lx=tlx+Math.trunc(((blx-tlx)*(y-ty))/(by-ty));            rx=trx+Math.trunc(((brx-trx)*(y-ty))/(by-ty));                        pIdx=(y*this.shadowMapSize)+lx;                            for (x=lx;x<rx;x++) {                this.lumData[pIdx++]=lum;            }        }    }            //        // create a bitmap from the data        //    finish()    {        let n;        let ctx;        let imgData,pIdx,pixel;                this.canvas=document.createElement('canvas');        this.canvas.width=this.shadowMapSize;        this.canvas.height=this.shadowMapSize;                ctx=this.canvas.getContext('2d');        imgData=ctx.getImageData(0,0,this.shadowMapSize,this.shadowMapSize);                pIdx=0;                for (n=0;n!==(this.shadowMapSize*this.shadowMapSize);n++) {            pixel=this.lumData[n]*255.0;            imgData.data[pIdx++]=pixel;            imgData.data[pIdx++]=pixel;            imgData.data[pIdx++]=pixel;            imgData.data[pIdx++]=255;        }                this.canvas.getContext('2d').putImageData(imgData,0,0);    }}//// this object contains one of the lights in the scene,// plus a list of all it's collision meshes to speed// up the tracing//class ShadowmapLightClass{    constructor(core,mapLight)    {        this.core=core;        this.position=mapLight.position;        this.intensity=mapLight.intensity;        this.invertIntensity=mapLight.invertIntensity;        this.exponent=mapLight.exponent;                    // some ray trace optimization values                    this.lastBlockMeshIdx=-1;        this.lastBlockTriangleIdx=-1;            // all the meshes that collide with            // the light globe                    this.collideMeshes=[];    }        calculateCollisionList()    {        let n,mesh;        let pnt=new PointClass(0,0,0);        let map=this.core.map;                for (n=0;n!==map.meshList.meshes.length;n++) {            mesh=map.meshList.meshes[n];            if (mesh.moveable) continue;                            // skipped meshes                        if (map.json.shadowMapSkinBitmaps!==undefined) {                if (map.json.shadowMapSkipBitmaps.indexOf(mesh.bitmap.simpleName)!==-1) continue;            }                            // check if center in light globe                            if (mesh.center.distance(this.position)<this.intensity) {                this.collideMeshes.push(n);                continue;            }                            // now the 8 cube corners                        pnt.setFromValues(mesh.xBound.min,mesh.yBound.min,mesh.zBound.min);            if (pnt.distance(this.position)<this.intensity) {                this.collideMeshes.push(n);                continue;            }            pnt.setFromValues(mesh.xBound.min,mesh.yBound.min,mesh.zBound.max);            if (pnt.distance(this.position)<this.intensity) {                this.collideMeshes.push(n);                continue;            }            pnt.setFromValues(mesh.xBound.max,mesh.yBound.min,mesh.zBound.min);            if (pnt.distance(this.position)<this.intensity) {                this.collideMeshes.push(n);                continue;            }            pnt.setFromValues(mesh.xBound.max,mesh.yBound.min,mesh.zBound.max);            if (pnt.distance(this.position)<this.intensity) {                this.collideMeshes.push(n);                continue;            }                        pnt.setFromValues(mesh.xBound.min,mesh.yBound.max,mesh.zBound.min);            if (pnt.distance(this.position)<this.intensity) {                this.collideMeshes.push(n);                continue;            }            pnt.setFromValues(mesh.xBound.min,mesh.yBound.max,mesh.zBound.max);            if (pnt.distance(this.position)<this.intensity) {                this.collideMeshes.push(n);                continue;            }            pnt.setFromValues(mesh.xBound.max,mesh.yBound.max,mesh.zBound.min);            if (pnt.distance(this.position)<this.intensity) {                this.collideMeshes.push(n);                continue;            }            pnt.setFromValues(mesh.xBound.max,mesh.yBound.max,mesh.zBound.max);            if (pnt.distance(this.position)<this.intensity) {                this.collideMeshes.push(n);                continue;            }        }    }}//// generate shadow map class//export default class ShadowmapGeneratorClass{    constructor(core,dialog,callbackFunc)    {        this.core=core;        this.dialog=dialog;        this.callbackFunc=callbackFunc;                this.debugTimestamp=0;                    // constants                    this.SHADOWMAP_TEXTURE_SIZE=2048; //1024;        this.SHADOWMAP_CHUNK_SPLIT=32; //16;                  // how many chunks in both the X and Y direction        this.SHADOWMAP_CHUNK_SIZE=Math.trunc(this.SHADOWMAP_TEXTURE_SIZE/this.SHADOWMAP_CHUNK_SPLIT);    // square pixel size of chunks        this.SHADOWMAP_CHUNK_PER_TEXTURE=(this.SHADOWMAP_CHUNK_SPLIT*this.SHADOWMAP_CHUNK_SPLIT)*2;        // how many chunks in a single texture (two triangles)        this.SHADOW_MIN_VALUE=0.3;                this.RENDER_NORMAL=0;        this.RENDER_ALL_BLACK=1;        this.RENDER_ALL_WHITE=2;            // array of bitmaps that make up the shadowmaps            // each is an object with a canvas and the last chunk            // drawn to (the chunkIdx)        this.shadowmapIdx=0;        this.shadowmapList=[];                    // to track which shadowmap each mesh is in                    this.meshShadowMapIndex=new Int16Array(this.core.map.meshList.meshes.length);            // lights in ray trace                    this.lights=[];            // some pre-allocates                    this.lightVector=new PointClass(0,0,0);        this.lightVectorNormal=new PointClass(0,0,0);                this.lightBoundX=new BoundClass(0,0);        this.lightBoundY=new BoundClass(0,0);        this.lightBoundZ=new BoundClass(0,0);                    this.v0=new PointClass(0,0,0);      // the 3D triangle in the map        this.v1=new PointClass(0,0,0);        this.v2=new PointClass(0,0,0);                this.normal=new PointClass(0,0,0);  // a single normal to eliminate lights                this.t0=new PointClass(0,0,0);      // the 2D shadow map projection        this.t1=new PointClass(0,0,0);        this.t2=new PointClass(0,0,0);                this.mat2d=new Matrix4Class();      // these are used to create a transformation matrix from 2D render to 3D triangle        this.mat2dInvert=new Matrix4Class();        this.mat3d=new Matrix4Class();        this.transformMat=new Matrix4Class();                this.rayPoint=new PointClass(0,0,0);        this.rayTraceVertexColor=new ColorClass(0,0,0);                Object.seal(this);    }        getMeshTriangleVertexes(mesh,tIdx,v0,v1,v2,normal)    {        let vIdx;                tIdx*=3;        vIdx=mesh.indexArray[tIdx]*3;        v0.setFromValues(mesh.vertexArray[vIdx],mesh.vertexArray[vIdx+1],mesh.vertexArray[vIdx+2]);        if (normal!==null) normal.setFromValues(mesh.normalArray[vIdx],mesh.normalArray[vIdx+1],mesh.normalArray[vIdx+2]);                vIdx=mesh.indexArray[tIdx+1]*3;        v1.setFromValues(mesh.vertexArray[vIdx],mesh.vertexArray[vIdx+1],mesh.vertexArray[vIdx+2]);                vIdx=mesh.indexArray[tIdx+2]*3;        v2.setFromValues(mesh.vertexArray[vIdx],mesh.vertexArray[vIdx+1],mesh.vertexArray[vIdx+2]);    }            //        // ray tracing        //    rayTraceTriangle(vrt,vct,t0,v10,v20)    {        let perpVectorX,perpVectorY,perpVectorZ;        let det,invDet,u,v;        let lineToTrigPointVectorX,lineToTrigPointVectorY,lineToTrigPointVectorZ;        let lineToTrigPerpVectorX,lineToTrigPerpVectorY,lineToTrigPerpVectorZ;                    // vrt = point to ray trace            // v10[x,y,z]=t1[x,y,z]-t0[x,y,z]            // v20[x,y,z]=t2[x,y,z]-t0[x,y,z]                //this.v10.setFromSubPoint(t1,t0);  // all this is cached, code here for reference        //this.v20.setFromSubPoint(t2,t0);            // calculate the determinate            // perpVector is cross(vector,v2)            // det is dot(v1,perpVector)        perpVectorX=(vct.y*v20.z)-(vct.z*v20.y);        perpVectorY=(vct.z*v20.x)-(vct.x*v20.z);        perpVectorZ=(vct.x*v20.y)-(vct.y*v20.x);        det=(v10.x*perpVectorX)+(v10.y*perpVectorY)+(v10.z*perpVectorZ);            // is line on the same plane as triangle?        if ((det>-0.00001) && (det<0.00001)) return(false);            // get the inverse determinate        invDet=1.0/det;            // calculate triangle U and test            // lineToTrigPointVector is vector from vertex to triangle point 0            // u is invDet * dot(lineToTrigPointVector,perpVector)        lineToTrigPointVectorX=vrt.x-t0.x;        lineToTrigPointVectorY=vrt.y-t0.y;        lineToTrigPointVectorZ=vrt.z-t0.z;        u=invDet*((lineToTrigPointVectorX*perpVectorX)+(lineToTrigPointVectorY*perpVectorY)+(lineToTrigPointVectorZ*perpVectorZ));        if ((u<0.0) || (u>1.0)) return(false);            // calculate triangle V and test            // lineToTrigPerpVector is cross(lineToTrigPointVector,v1)            // v is invDet * dot(vector,lineToTrigPerpVector)        lineToTrigPerpVectorX=(lineToTrigPointVectorY*v10.z)-(lineToTrigPointVectorZ*v10.y);        lineToTrigPerpVectorY=(lineToTrigPointVectorZ*v10.x)-(lineToTrigPointVectorX*v10.z);        lineToTrigPerpVectorZ=(lineToTrigPointVectorX*v10.y)-(lineToTrigPointVectorY*v10.x);        v=invDet*((vct.x*lineToTrigPerpVectorX)+(vct.y*lineToTrigPerpVectorY)+(vct.z*lineToTrigPerpVectorZ));        if ((v<0.0) || ((u+v)>1.0)) return(false);            // t is the point on the line, from the            // invDet*dot(v2,lineToTrigPerpVector)            // this is a little different then normal ray trace            // hits, we add in an extra 0.01 slop so polygons that are            // touching each other don't have edges grayed in        let t=invDet*((v20.x*lineToTrigPerpVectorX)+(v20.y*lineToTrigPerpVectorY)+(v20.z*lineToTrigPerpVectorZ));        return((t>0.01)&&(t<1.0));    }    rayTraceMap(lightList,vrt)    {        let n,nLight,trigCount;        let light;        let k,p,hit,mesh,nMesh;        let dist;        let map=this.core.map;                    // we use the passed in light list which is a cut down            // list precalculcated from mesh/light interactions and            // removing any lights that are facing away from the            // front side of the triangle        nLight=lightList.length;        for (n=0;n!==nLight;n++) {            light=lightList[n];                // light within light range?            dist=light.position.distance(vrt);            if (dist>light.intensity) continue;                // vector from render point to light            this.lightVector.setFromSubPoint(light.position,vrt);                // we keep a list of the last mesh                // to block a light and we check that first                // because a lot of the time the same mesh will come                // up rendering a triangle in a mesh               if (light.lastBlockMeshIdx!==-1) {                mesh=map.meshList.meshes[light.lastBlockMeshIdx];                if (this.rayTraceTriangle(vrt,this.lightVector,mesh.shadowmapCacheV0[light.lastBlockTriangleIdx],mesh.shadowmapCacheV10[light.lastBlockTriangleIdx],mesh.shadowmapCacheV20[light.lastBlockTriangleIdx])) continue;            }                // ray bounding            this.lightBoundX.setFromValues(vrt.x,light.position.x);            this.lightBoundY.setFromValues(vrt.y,light.position.y);            this.lightBoundZ.setFromValues(vrt.z,light.position.z);                // any hits?                // only run through the meshes that collide with                // the light globe because only they can block            hit=false;            nMesh=light.collideMeshes.length;            for (k=0;k!==nMesh;k++) {                mesh=map.meshList.meshes[light.collideMeshes[k]];                                    // only deal with meshes in the ray to light bound                    // do x/z first these are probably quicker eliminations                                    if ((mesh.xBound.min>=this.lightBoundX.max) || (mesh.xBound.max<=this.lightBoundX.min)) continue;                if ((mesh.zBound.min>=this.lightBoundZ.max) || (mesh.zBound.max<=this.lightBoundZ.min)) continue;                if ((mesh.yBound.min>=this.lightBoundY.max) || (mesh.yBound.max<=this.lightBoundY.min)) continue;                    // do all the trigs                                    trigCount=mesh.trigCount;                for (p=0;p!==trigCount;p++) {                    if (this.rayTraceTriangle(vrt,this.lightVector,mesh.shadowmapCacheV0[p],mesh.shadowmapCacheV10[p],mesh.shadowmapCacheV20[p])) {                        hit=true;                        light.lastBlockMeshIdx=light.collideMeshes[k];                        light.lastBlockTriangleIdx=p;                        break;                    }                }                if (hit) break;            }                            // at least one light got through, not in shadow                            if (!hit) return(true);        }                return(false);    }                //        // render shadowmap for mesh and triangle        //    renderTriangle(shadowmap,meshIdx,v0,v1,v2,normal,t0,t1,t2)    {        let n,x,y,lx,rx,ty,by,pIdx;        let tlx,blx,trx,brx;        let dist,allBlack,allWhite;        let light,lightList;        let lumData=shadowmap.lumData;                    // create a light list to check the            // triangle against                lightList=[];        for (n=0;n!==this.lights.length;n++) {            light=this.lights[n];                            // only consider a light if it collides                // with this mesh                            if (light.collideMeshes.indexOf(meshIdx)===-1) continue;                            // eliminate for distance                            dist=light.position.distance(v0);            if (dist>light.intensity) continue;                // check all the vertex normals                // only eliminate if all vertexes are                // behind              this.lightVectorNormal.setFromValues((light.position.x-v0.x),(light.position.y-v0.y),(light.position.z-v0.z));            this.lightVectorNormal.normalize();            if (this.lightVectorNormal.dot(normal)>=0.0) {                lightList.push(light);                continue;            }                        this.lightVectorNormal.setFromValues((light.position.x-v1.x),(light.position.y-v1.y),(light.position.z-v1.z));            this.lightVectorNormal.normalize();            if (this.lightVectorNormal.dot(normal)>=0.0) {                lightList.push(light);                continue;            }                        this.lightVectorNormal.setFromValues((light.position.x-v2.x),(light.position.y-v2.y),(light.position.z-v2.z));            this.lightVectorNormal.normalize();            if (this.lightVectorNormal.dot(normal)>=0.0) {                lightList.push(light);                continue;            }        }                    // if no lights, it's all black                    if (lightList.length===0) return(this.RENDER_ALL_BLACK);                    // flag to see if we only wrote black or white lum values                    allBlack=true;        allWhite=true;                    // create a transformation matrix to get            // the 2d triangle to the 3d one            // the transform matrix is [3d points]*invert([2d point (z=0)])                    this.mat2d.fromArray([t0.x,t0.y,0,1,t1.x,t1.y,0,1,t2.x,t2.y,0,1,1,1,1,1]);        this.mat2dInvert.setFromInvertMatrix(this.mat2d);        this.mat3d.fromArray([v0.x,v0.y,v0.z,1,v1.x,v1.y,v1.z,1,v2.x,v2.y,v2.z,1,1,1,1,1]);        this.transformMat.setFromMultiply(this.mat3d,this.mat2dInvert);                    // render the triangle                    if (t0.y===t1.y) {            ty=t0.y;            by=t2.y;                        tlx=blx=t0.x;            trx=t1.x;            brx=t2.x;        }        else {            ty=t0.y;            by=t1.y;                        tlx=t0.x;            blx=t2.x;            trx=brx=t0.x;        }                for (y=ty;y<by;y++) {            lx=tlx+Math.trunc(((blx-tlx)*(y-ty))/(by-ty));            rx=trx+Math.trunc(((brx-trx)*(y-ty))/(by-ty));                        pIdx=(y*this.SHADOWMAP_TEXTURE_SIZE)+lx;                            for (x=lx;x<rx;x++) {                            // ray trace the 3d pixel                                this.rayPoint.setFromValues(x,y,0);                    this.rayPoint.matrixMultiply(this.transformMat);                                if (this.rayTraceMap(lightList,this.rayPoint)) {                    lumData[pIdx]=1.0;                    allBlack=false;                }                else {                    allWhite=false;                }                                pIdx++;            }        }                if (allBlack) return(this.RENDER_ALL_BLACK);        if (allWhite) return(this.RENDER_ALL_WHITE);        return(this.RENDER_NORMAL);    }    renderMesh(meshIdx)    {        let n,renderResult,resetOnce,originalChunkIdx;        let vertexShadowArray,uvShadowArray;        let mesh,shadowmap,highlight;        let map=this.core.map;                mesh=map.meshList.meshes[meshIdx];                this.dialog.updateProgress((3+(96*(meshIdx/map.meshList.meshes.length))),('Mesh '+meshIdx+'/'+map.meshList.meshes.length));                    // moveable or highlighted meshes are skipped                        highlight=false;        if (map.json.shadowMapHighlightBitmaps!==undefined) highlight=(map.json.shadowMapHighlightBitmaps.indexOf(mesh.bitmap.simpleName)!==-1);        if ((mesh.moveable) || (highlight)) {            this.meshShadowMapIndex[meshIdx]=0;            mesh.vertexShadowArray=null;            mesh.uvShadowArray=null;                        this.nextMesh(meshIdx);            return;        }                    // we use regular arrays so we            // can do push, converting them to            // floats at the end                    vertexShadowArray=[];        uvShadowArray=[];                    // we need to put the entire mesh into            // one shadow map, but we don't know how many            // triangles we will have so we start filling            // and fail and start over if we go over                    resetOnce=false;                while (true) {                        shadowmap=this.shadowmapList[this.shadowmapIdx];            originalChunkIdx=shadowmap.chunkIdx;                // run through the triangles                // if no lights hit a triangle, it's                // autoset to chunk 0, the all black trig            for (n=0;n!==mesh.trigCount;n++) {                    // get vertexes for the 3D world triangle                    // and a single normal                this.getMeshTriangleVertexes(mesh,n,this.v0,this.v1,this.v2,this.normal);                    // and the vertexes for the 2D chunk shadowmap                shadowmap.getChunkDrawCoordinates(shadowmap.chunkIdx,this.t0,this.t1,this.t2);                    // render the triangle                renderResult=this.renderTriangle(shadowmap,meshIdx,this.v0,this.v1,this.v2,this.normal,this.t0,this.t1,this.t2);                    // if all white, then skip any triangles                    // as they won't draw anything                if (renderResult===this.RENDER_ALL_WHITE) continue;                    // advance chunk if not all black (which means                    // we used a chunk instead of the default all black chunk                if (renderResult===this.RENDER_ALL_BLACK) {                    shadowmap.getChunkUVCoordinates(0,this.t0,this.t1,this.t2);                }                else {                    shadowmap.getChunkUVCoordinates(shadowmap.chunkIdx,this.t0,this.t1,this.t2);                    shadowmap.chunkIdx++;                                            // did we overfill this shadowmap and need                        // to start over on a new one?                                            if (shadowmap.chunkIdx>=this.SHADOWMAP_CHUNK_PER_TEXTURE) break;                }                    // add the shadow map pass triangle                vertexShadowArray.push(this.v0.x,this.v0.y,this.v0.z);                uvShadowArray.push((this.t0.x/this.SHADOWMAP_TEXTURE_SIZE),(this.t0.y/this.SHADOWMAP_TEXTURE_SIZE));                vertexShadowArray.push(this.v1.x,this.v1.y,this.v1.z);                uvShadowArray.push((this.t1.x/this.SHADOWMAP_TEXTURE_SIZE),(this.t1.y/this.SHADOWMAP_TEXTURE_SIZE));                vertexShadowArray.push(this.v2.x,this.v2.y,this.v2.z);                uvShadowArray.push((this.t2.x/this.SHADOWMAP_TEXTURE_SIZE),(this.t2.y/this.SHADOWMAP_TEXTURE_SIZE));            }                            // did we go over and need to repeat?                // we only do this once, otherwise it's a mesh too                // big to fit into one shadow map and we just only do                // the trigs that fit                            if (shadowmap.chunkIdx>=this.SHADOWMAP_CHUNK_PER_TEXTURE) {                if (resetOnce) {                    console.info('mesh '+meshIdx+':'+mesh.name+' has too many triangles for shadowmap');                    break;                }                else {                    resetOnce=true;                        // put the map back to it's earlier state                    for (n=originalChunkIdx;n<shadowmap.chunkIdx;n++) {                        shadowmap.fillChunk(n,this.SHADOW_MIN_VALUE);                    }                    shadowmap.chunkIdx=originalChunkIdx;                        // now move onto a new map                    this.shadowmapIdx=this.shadowmapList.length;                    this.shadowmapList.push(new ShadowmapBitmapClass(this));                    console.info('reset='+this.shadowmapIdx);                    continue;                }            }                        break;        }                    // now add the vertex and uvs                    if (vertexShadowArray.length===0) {            this.meshShadowMapIndex[meshIdx]=0;            mesh.vertexShadowArray=null;            mesh.uvShadowArray=null;        }        else {                // map meshes have a temporary index for                // the light map.  we don't create the light                // maps into the very end (as they can be shared)                // so this is used for tracking it until than            this.meshShadowMapIndex[meshIdx]=this.shadowmapIdx;                        mesh.vertexShadowArray=new Float32Array(vertexShadowArray);            mesh.uvShadowArray=new Float32Array(uvShadowArray);        }        this.nextMesh(meshIdx);    }        nextMesh(meshIdx)    {            // move on to next mesh            // if out of mesh, finish up creation        meshIdx++;        if (meshIdx>=this.core.map.meshList.meshes.length) {            setTimeout(this.createFinish.bind(this),1);            return;        }            // next mesh        setTimeout(this.renderMesh.bind(this,meshIdx),1);    }            //        // build shadowmap model bin        // mesh count (int)        //   bitmap index (int)        //   vertex byte count (int)        //   uv byte count (int)        //   vertexes (array of 3 floats)        //   uvs (array of 2 floats)        //            buildShadowMapModelBin()    {        let n,k,len,offset,mesh;        let data,dataView;        let byteBuffer,str;        let map=this.core.map;        let nMesh=map.meshList.meshes.length;                    // calculate the length                    len=4;      // mesh count                for (n=0;n!=nMesh;n++) {            mesh=map.meshList.meshes[n];                        len+=12;        // bitmap index and vertex/uv byte count            if (mesh.vertexShadowArray!==null) len+=((mesh.vertexShadowArray.length*4)+(mesh.uvShadowArray.length*4)); // vertex and UVs        }                    // fill the data                    data=new ArrayBuffer(len);                dataView=new DataView(data,0,len);                dataView.setInt32(0,nMesh);                offset=4;                for (n=0;n!=nMesh;n++) {            mesh=map.meshList.meshes[n];                        if (mesh.vertexShadowArray===null) {                dataView.setInt32(offset,0);                offset+=4;                dataView.setInt32(offset,0);                offset+=4;                dataView.setInt32(offset,0);                offset+=4;            }            else {                dataView.setInt32(offset,this.meshShadowMapIndex[n]);                offset+=4;                dataView.setInt32(offset,mesh.vertexShadowArray.length);                offset+=4;                dataView.setInt32(offset,mesh.uvShadowArray.length);                offset+=4;                for (k=0;k!==mesh.vertexShadowArray.length;k++) {                    dataView.setFloat32(offset,mesh.vertexShadowArray[k]);                    offset+=4;                }                for (k=0;k!==mesh.uvShadowArray.length;k++) {                    dataView.setFloat32(offset,mesh.uvShadowArray[k]);                    offset+=4;                }            }        }                    // now do the base64 conversion                    byteBuffer=new Uint8Array(data);        str='';                for (n=0;n!==byteBuffer.byteLength;n++) {            str+=String.fromCharCode(byteBuffer[n]);        }                return(btoa(str));    }            //        // create shadowmaps        // creation has to be done by a timer because this        // is too slow and browsers will bounce the script        //    create()    {        this.debugTimestamp=Date.now();                this.dialog.updateProgress(1,'Setup Lights');        setTimeout(this.createSetupLights.bind(this),1);    }            createSetupLights()    {        let n,light,effect;        let map=this.core.map;                    // build a list of lights for the            // scene that have mesh collisions                    this.lights=[];                for (n=0;n!==map.lightList.lights.length;n++) {            light=new ShadowmapLightClass(this.core,map.lightList.lights[n]);            light.calculateCollisionList();            this.lights.push(light);        }                for (n=0;n!==map.effectList.effects.length;n++) {            effect=map.effectList.effects[n];            if (effect.light===null) continue;                        light=new ShadowmapLightClass(this.core,effect.light);            light.calculateCollisionList();            this.lights.push(light);        }                this.dialog.updateProgress(2,'Setup Trigs');        setTimeout(this.createSetupCacheTrigs.bind(this),1);    }        createSetupCacheTrigs()    {        let n,k,trigCount,mesh;        let map=this.core.map;                for (n=0;n!==map.meshList.meshes.length;n++) {            mesh=map.meshList.meshes[n];                        trigCount=mesh.trigCount;                        mesh.shadowmapCacheV0=[];            mesh.shadowmapCacheV10=[];            mesh.shadowmapCacheV20=[];                        for (k=0;k!==trigCount;k++) {                this.getMeshTriangleVertexes(mesh,k,this.v0,this.v1,this.v2,null);                                mesh.shadowmapCacheV0.push(this.v0.copy());                mesh.shadowmapCacheV10.push(new PointClass((this.v1.x-this.v0.x),(this.v1.y-this.v0.y),(this.v1.z-this.v0.z)));                mesh.shadowmapCacheV20.push(new PointClass((this.v2.x-this.v0.x),(this.v2.y-this.v0.y),(this.v2.z-this.v0.z)));            }        }                    // start the shadowmap cache            // with the initial shadow map                    this.shadowmapIdx=0;        this.shadowmapList.push(new ShadowmapBitmapClass(this));            // run through the meshes            // on a timer        setTimeout(this.renderMesh.bind(this,0),1);    }    async createFinish()    {        let n,mesh;        let upload,fileName,data;        let map=this.core.map;                this.dialog.updateProgress(99,'Uploading');                    // make canvases for all the shadowmaps                    for (n=0;n!==this.shadowmapList.length;n++) {            this.shadowmapList[n].finish();        }                    // clear the caches                    for (n=0;n!==map.meshList.meshes.length;n++) {            mesh=map.meshList.meshes[n];            mesh.shadowmapCacheV0=null;            mesh.shadowmapCacheV10=null;            mesh.shadowmapCacheV20=null;        }            // upload the data                    upload=new UploadClass(this.core);                    // shadow maps as pngs                for (n=0;n!==this.shadowmapList.length;n++) {            fileName='shadowmap_'+n+'.png';            data=this.shadowmapList[n].canvas.toDataURL();            data=data.substring(data.indexOf(',')+1);            upload.upload(fileName,data);   // already in base64        }                    // the data                    data=this.buildShadowMapModelBin(); // returns base64        upload.upload('shadowmap.bin',data);        //this.debugShadowmapBitmap(this.shadowmapList[0]);                console.info('time='+(Date.now()-this.debugTimestamp));            // finish with the callback        this.callbackFunc();    }            //        // quick debugging function        //            debugShadowmapBitmap(shadowmapBitmap)    {        let n,pIdx,pixel;        let debugCanvas,ctx;        let imgData;                debugCanvas=document.createElement('canvas');        debugCanvas.style.position='absolute';        debugCanvas.style.left='0px';        debugCanvas.style.top='0px';        debugCanvas.style.zIndex=1000;        debugCanvas.style.touchAction='none';        debugCanvas.width=this.SHADOWMAP_TEXTURE_SIZE;        debugCanvas.height=this.SHADOWMAP_TEXTURE_SIZE;        document.body.appendChild(debugCanvas);                ctx=debugCanvas.getContext('2d');        imgData=ctx.getImageData(0,0,this.SHADOWMAP_TEXTURE_SIZE,this.SHADOWMAP_TEXTURE_SIZE);                pIdx=0;                for (n=0;n!==(this.SHADOWMAP_TEXTURE_SIZE*this.SHADOWMAP_TEXTURE_SIZE);n++) {            pixel=shadowmapBitmap.lumData[n]*255.0;            imgData.data[pIdx++]=pixel;            imgData.data[pIdx++]=pixel;            imgData.data[pIdx++]=pixel;            imgData.data[pIdx++]=255;        }                debugCanvas.getContext('2d').putImageData(imgData,0,0);    }}