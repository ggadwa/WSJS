import PointClass from '../utility/point.js';import BoundClass from '../utility/bound.js';import ColorClass from '../utility/color.js';import Matrix4Class from '../utility/matrix4.js';//// lightmap bitmap class// records each generated lightmap// canvas and the last chunk written to//class ShadowmapBitmapClass{    constructor(shadowmapGenerator)    {        let n,idx;        let pixelCount,data;                this.shadowmapGenerator=shadowmapGenerator;                    // some constants                    this.chunkSize=shadowmapGenerator.LIGHTMAP_CHUNK_SIZE;        this.chunkPerRow=Math.trunc(shadowmapGenerator.LIGHTMAP_TEXTURE_SIZE/this.chunkSize);                    // the final bitmap                    this.bitmap=null;            // setup the canvas        this.canvas=document.createElement('canvas');        this.canvas.width=shadowmapGenerator.LIGHTMAP_TEXTURE_SIZE;        this.canvas.height=shadowmapGenerator.LIGHTMAP_TEXTURE_SIZE;        this.ctx=this.canvas.getContext('2d');        this.imgData=this.ctx.getImageData(0,0,shadowmapGenerator.LIGHTMAP_TEXTURE_SIZE,shadowmapGenerator.LIGHTMAP_TEXTURE_SIZE);        this.pixelData=this.imgData.data;            // data for blur        this.blurData=new Uint8ClampedArray(this.pixelData.length);            // clear to black with            // open alpha (we use this later            // for smearing)        pixelCount=shadowmapGenerator.LIGHTMAP_TEXTURE_SIZE*shadowmapGenerator.LIGHTMAP_TEXTURE_SIZE;        idx=0;        data=this.pixelData;        for (n=0;n!==pixelCount;n++) {            data[idx++]=0;            data[idx++]=0;            data[idx++]=0;            data[idx++]=255;        }            // the first two chunks are always            // black and white                    this.fillChunk(0,new ColorClass(0,0,0));    // supergumba -- testing        this.fillChunk(1,new ColorClass(1,1,1));            // start at chunk 2 as the first free chunk        this.chunkIdx=2;                Object.seal(this);    }            //        // chunk utilities        //            getChunkCoordinates(cIdx,p0,p1,p2)    {        let x,y;        let secondTrig;                secondTrig=cIdx%2;        cIdx=cIdx>>1;                x=(cIdx%this.chunkPerRow)*this.chunkSize;        y=Math.trunc(cIdx/this.chunkPerRow)*this.chunkSize;                if (!secondTrig) {            p0.setFromValues(x,y,0);            p1.setFromValues((x+this.chunkSize),y,0);            p2.setFromValues(x,(y+this.chunkSize),0);        }        else {            p0.setFromValues((x+this.chunkSize),y,0);            p1.setFromValues((x+this.chunkSize),(y+this.chunkSize),0);            p2.setFromValues(x,(y+this.chunkSize),0);        }    }        fillChunk(cIdx,color)    {        let pIdx;        let x,y,ty,by,lx,rx,tlx,blx,trx,brx;        let p0=new PointClass(0,0,0);        let p1=new PointClass(0,0,0);        let p2=new PointClass(0,0,0);                this.getChunkCoordinates(cIdx,p0,p1,p2);                if (p0.y===p1.y) {            ty=p0.y;            by=p2.y;                        tlx=blx=p0.x;            trx=p1.x;            brx=p2.x;        }        else {            ty=p0.y;            by=p1.y;                        tlx=p0.x;            blx=p2.x;            trx=brx=p0.x;        }                for (y=ty;y<by;y++) {            lx=tlx+Math.trunc(((blx-tlx)*(y-ty))/(by-ty));            rx=trx+Math.trunc(((brx-trx)*(y-ty))/(by-ty));                        pIdx=((y*this.imgData.width)+lx)*4;                            for (x=lx;x<rx;x++) {                this.pixelData[pIdx++]=color.r*255.0;                this.pixelData[pIdx++]=color.g*255.0;                this.pixelData[pIdx++]=color.b*255.0;                this.pixelData[pIdx++]=255;            }        }    }            //        // write the data back to the canvas        // and build the bitmap        //    finish()    {        this.ctx.putImageData(this.imgData,0,0);                this.bitmap=this.shadowmapGenerator.core.bitmapList.addShadowmap(this.canvas);    }}//// this is a object used to hold the last mesh/trig// that blocked a light.  we use this as an optimization// as a trig that blocked this light probably blocks// further pixels in the current trig render//class ShadowmapLastBlockClass{    constructor()    {        this.meshIdx=-1;        this.cacheTrigIdx=-1;                Object.seal(this);    }}//// generate shadow map class//export default class ShadowmapGeneratorClass{    constructor(core,callbackFunc)    {        this.core=core;        this.callbackFunc=callbackFunc;                this.debugTimestamp=0;                    // constants                    this.LIGHTMAP_TEXTURE_SIZE=1024;        this.LIGHTMAP_CHUNK_SPLIT=16;                  // how many chunks in both the X and Y direction        this.LIGHTMAP_CHUNK_SIZE=Math.trunc(this.LIGHTMAP_TEXTURE_SIZE/this.LIGHTMAP_CHUNK_SPLIT);    // square pixel size of chunks        this.LIGHTMAP_CHUNK_PER_TEXTURE=(this.LIGHTMAP_CHUNK_SPLIT*this.LIGHTMAP_CHUNK_SPLIT)*2;        // how many chunks in a single texture            // chunk is one block available to draw a triangle's            // shadowmap            // array of bitmaps that make up the shadowmaps            // each is an object with a canvas and the last chunk            // drawn to (the chunkIdx)        this.shadowmapList=[];                    // to track which shadowmap each mesh is in                    this.meshShadowMapIndex=new Int16Array(this.core.map.meshList.meshes.length);            // the last block optimization list        this.lastBlockList=[];            // some pre-allocates                    this.lightVector=new PointClass(0,0,0);        this.lightVectorNormal=new PointClass(0,0,0);                this.lightBoundX=new BoundClass(0,0);        this.lightBoundY=new BoundClass(0,0);        this.lightBoundZ=new BoundClass(0,0);                    this.v0=new PointClass(0,0,0);      // the 3D triangle in the map        this.v1=new PointClass(0,0,0);        this.v2=new PointClass(0,0,0);                this.normal=new PointClass(0,0,0);  // a single normal to eliminate lights                this.t0=new PointClass(0,0,0);      // the 2D shadow map projection        this.t1=new PointClass(0,0,0);        this.t2=new PointClass(0,0,0);                this.mat2d=new Matrix4Class();      // these are used to create a transformation matrix from 2D render to 3D triangle        this.mat2dInvert=new Matrix4Class();        this.mat3d=new Matrix4Class();        this.transformMat=new Matrix4Class();                this.rayPoint=new PointClass(0,0,0);        this.rayTraceVertexColor=new ColorClass(0,0,0);                this.v10=new PointClass(0,0,0);        this.v20=new PointClass(0,0,0);                this.tt0=new PointClass(0,0,0);        this.tt1=new PointClass(0,0,0);        this.tt2=new PointClass(0,0,0);                Object.seal(this);    }            //        // border and smear polygons        //            smudgeChunk(lightBitmap,lft,top)    {        let x,y,idx;        let r,g,b;        let hasColor;                let rgt=lft+this.LIGHTMAP_CHUNK_SIZE;        let bot=top+this.LIGHTMAP_CHUNK_SIZE;                let pixelData=lightBitmap.pixelData;                    // we run through the entire chunk            // from left to right, right to left,            // top to bottom, and bottom to top            // smearing any colors we find to            // build an edge around the triangle        for (y=top;y!==bot;y++) {                        idx=((y*this.LIGHTMAP_TEXTURE_SIZE)+lft)*4;            hasColor=false;                        for (x=lft;x!==rgt;x++) {                                if (pixelData[idx+3]!==0) {                    hasColor=true;                    r=pixelData[idx];                    g=pixelData[idx+1];                    b=pixelData[idx+2];                }                else {                    if (hasColor) {                        pixelData[idx]=r;                        pixelData[idx+1]=g;                        pixelData[idx+2]=b;                        pixelData[idx+3]=255;                    }                }                                idx+=4;            }                        idx=((y*this.LIGHTMAP_TEXTURE_SIZE)+(rgt-1))*4;            hasColor=false;                        for (x=lft;x!==rgt;x++) {                                if (pixelData[idx+3]!==0) {                    hasColor=true;                    r=pixelData[idx];                    g=pixelData[idx+1];                    b=pixelData[idx+2];                }                else {                    if (hasColor) {                        pixelData[idx]=r;                        pixelData[idx+1]=g;                        pixelData[idx+2]=b;                        pixelData[idx+3]=255;                    }                }                             idx-=4;            }        }                for (x=lft;x!==rgt;x++) {                        hasColor=false;                        for (y=top;y!==bot;y++) {                                idx=((y*this.LIGHTMAP_TEXTURE_SIZE)+x)*4;                if (pixelData[idx+3]!==0) {                    hasColor=true;                    r=pixelData[idx];                    g=pixelData[idx+1];                    b=pixelData[idx+2];                }                else {                    if (hasColor) {                        pixelData[idx]=r;                        pixelData[idx+1]=g;                        pixelData[idx+2]=b;                        pixelData[idx+3]=255;                    }                }            }                        hasColor=false;                        for (y=(bot-1);y>=top;y--) {                                idx=((y*this.LIGHTMAP_TEXTURE_SIZE)+x)*4;                if (pixelData[idx+3]!==0) {                    hasColor=true;                    r=pixelData[idx];                    g=pixelData[idx+1];                    b=pixelData[idx+2];                }                else {                    if (hasColor) {                        pixelData[idx]=r;                        pixelData[idx+1]=g;                        pixelData[idx+2]=b;                        pixelData[idx+3]=255;                    }                }            }        }    }        blurChunk(lightBitmap,lft,top)    {        let n,idx;        let x,y,cx,cy,cxs,cxe,cys,cye;        let colCount,fCount,r,g,b;                let rgt=lft+this.LIGHTMAP_CHUNK_SIZE;        let bot=top+this.LIGHTMAP_CHUNK_SIZE;                let pixelData=lightBitmap.pixelData;        let blurData=lightBitmap.blurData;                    // default to current color if blur            // fails because of alpha                    for (y=top;y!==bot;y++) {            idx=((y*this.LIGHTMAP_TEXTURE_SIZE)+lft)*4;            for (x=lft;x!==rgt;x++) {                       blurData[idx]=pixelData[idx];                blurData[idx+1]=pixelData[idx+1];                blurData[idx+2]=pixelData[idx+2];                idx+=4;            }        }                    // blur pixels to count        for (n=0;n!==this.LIGHTMAP_BLUR_COUNT;n++) {            for (y=top;y!==bot;y++) {                cys=y-1;                if (cys<0) cys=0;                cye=y+2;                if (cye>=this.LIGHTMAP_TEXTURE_SIZE) cye=this.LIGHTMAP_TEXTURE_SIZE-1;                for (x=lft;x!==rgt;x++) {                        // get blur from 8 surrounding pixels                    colCount=0;                    r=g=b=0;                    cxs=x-1;                    if (cxs<0) cxs=0;                    cxe=x+2;                    if (cxe>=this.LIGHTMAP_TEXTURE_SIZE) cxe=this.LIGHTMAP_TEXTURE_SIZE-1;                    for (cy=cys;cy!==cye;cy++) {                        for (cx=cxs;cx!==cxe;cx++) {                            if ((cy===y) && (cx===x)) continue;       // ignore self                                // add up blur from the                                // original pixels                            idx=((cy*this.LIGHTMAP_TEXTURE_SIZE)+cx)*4;                            if (pixelData[idx+3]!==0) {                                r+=pixelData[idx];                                g+=pixelData[idx+1];                                b+=pixelData[idx+2];                                colCount++;                            }                        }                    }                                        if (colCount!==0) {                        fCount=1/colCount;                                                idx=((y*this.LIGHTMAP_TEXTURE_SIZE)+x)*4;                        blurData[idx]=Math.trunc(r*fCount);                        blurData[idx+1]=Math.trunc(g*fCount);                        blurData[idx+2]=Math.trunc(b*fCount);                    }                }            }                // transfer over the changed pixels            for (y=top;y!==bot;y++) {                idx=((y*this.LIGHTMAP_TEXTURE_SIZE)+lft)*4;                for (x=lft;x!==rgt;x++) {                           pixelData[idx]=blurData[idx];                    pixelData[idx+1]=blurData[idx+1];                    pixelData[idx+2]=blurData[idx+2];                    idx+=4;                }            }        }     }        getMeshTriangleVertexes(mesh,tIdx,v0,v1,v2,normal)    {        let vIdx;                tIdx*=3;        vIdx=mesh.indexArray[tIdx]*3;        v0.setFromValues(mesh.vertexArray[vIdx],mesh.vertexArray[vIdx+1],mesh.vertexArray[vIdx+2]);        if (normal!==null) normal.setFromValues(mesh.normalArray[vIdx],mesh.normalArray[vIdx+1],mesh.normalArray[vIdx+2]);                vIdx=mesh.indexArray[tIdx+1]*3;        v1.setFromValues(mesh.vertexArray[vIdx],mesh.vertexArray[vIdx+1],mesh.vertexArray[vIdx+2]);                vIdx=mesh.indexArray[tIdx+2]*3;        v2.setFromValues(mesh.vertexArray[vIdx],mesh.vertexArray[vIdx+1],mesh.vertexArray[vIdx+2]);    }            //        // ray tracing        //    rayTraceTriangle(vrt,vct,t0,t1,t2)    {        let perpVectorX,perpVectorY,perpVectorZ;        let det,invDet,u,v;        let lineToTrigPointVectorX,lineToTrigPointVectorY,lineToTrigPointVectorZ;        let lineToTrigPerpVectorX,lineToTrigPerpVectorY,lineToTrigPerpVectorZ;                this.v10.setFromSubPoint(t1,t0);        this.v20.setFromSubPoint(t2,t0);                    // we pass in a single vertex (t0x,t0y,t0z) and            // these pre-calculated items:            // v0 = vertex of triangle            // v10[x,y,z]=t1[x,y,z]-t0[x,y,z]            // v20[x,y,z]=t2[x,y,z]-t0[x,y,z]            // calculate the determinate            // perpVector is cross(vector,v2)            // det is dot(v1,perpVector)        perpVectorX=(vct.y*this.v20.z)-(vct.z*this.v20.y);        perpVectorY=(vct.z*this.v20.x)-(vct.x*this.v20.z);        perpVectorZ=(vct.x*this.v20.y)-(vct.y*this.v20.x);        det=(this.v10.x*perpVectorX)+(this.v10.y*perpVectorY)+(this.v10.z*perpVectorZ);            // is line on the same plane as triangle?        if ((det>-0.00001) && (det<0.00001)) return(false);            // get the inverse determinate        invDet=1.0/det;            // calculate triangle U and test            // lineToTrigPointVector is vector from vertex to triangle point 0            // u is invDet * dot(lineToTrigPointVector,perpVector)        lineToTrigPointVectorX=vrt.x-t0.x;        lineToTrigPointVectorY=vrt.y-t0.y;        lineToTrigPointVectorZ=vrt.z-t0.z;        u=invDet*((lineToTrigPointVectorX*perpVectorX)+(lineToTrigPointVectorY*perpVectorY)+(lineToTrigPointVectorZ*perpVectorZ));        if ((u<0.0) || (u>1.0)) return(false);            // calculate triangle V and test            // lineToTrigPerpVector is cross(lineToTrigPointVector,v1)            // v is invDet * dot(vector,lineToTrigPerpVector)        lineToTrigPerpVectorX=(lineToTrigPointVectorY*this.v10.z)-(lineToTrigPointVectorZ*this.v10.y);        lineToTrigPerpVectorY=(lineToTrigPointVectorZ*this.v10.x)-(lineToTrigPointVectorX*this.v10.z);        lineToTrigPerpVectorZ=(lineToTrigPointVectorX*this.v10.y)-(lineToTrigPointVectorY*this.v10.x);        v=invDet*((vct.x*lineToTrigPerpVectorX)+(vct.y*lineToTrigPerpVectorY)+(vct.z*lineToTrigPerpVectorZ));        if ((v<0.0) || ((u+v)>1.0)) return(false);            // t is the point on the line, from the            // invDet*dot(v2,lineToTrigPerpVector)            // this is a little different then normal ray trace            // hits, we add in an extra 0.01 slop so polygons that are            // touching each other don't have edges grayed in        let t=invDet*((this.v20.x*lineToTrigPerpVectorX)+(this.v20.y*lineToTrigPerpVectorY)+(this.v20.z*lineToTrigPerpVectorZ));        return((t>0.01)&&(t<1.0));    }    rayTraceMap(lightList,vrt,col)    {        let n,nLight,lightIdx,trigCount;        let light;        let k,p,hit,mesh,nMesh;        let trigRayTraceCache;        let lightVectorX,lightVectorY,lightVectorZ;        let dist,att;        let map=this.core.map;                    // start at black                    col.setFromValues(0,0,0);                    // we use the passed in light list which is a cut down            // list precalculcated from mesh/light interactions and            // removing any lights that are facing away from the            // front side of the triangle            // we precalculated a list of a single point on the            // triangle and two vectors for each side around that point            // to speed this up.  That's what the trigRayTraceCache is for        nLight=lightList.length;        for (n=0;n!==nLight;n++) {            light=lightList[n];                // light within light range?            dist=light.position.distance(vrt);            if (dist>light.intensity) continue;                // vector from render point to light            this.lightVector.setFromSubPoint(light.position,vrt);                // check the optimized list of last hits            /*                if (this.lastBlockList[lightIdx].meshIdx!==-1) {                mesh=map.meshes[this.lastBlockList[lightIdx].meshIdx];                if (this.rayTraceCollision(vx,vy,vz,lightVectorX,lightVectorY,lightVectorZ,mesh.trigRayTraceCache[this.lastBlockList[lightIdx].cacheTrigIdx])) continue;            }            */                // light bounding            this.lightBoundX.setFromValues(vrt.x,light.position.x);            this.lightBoundY.setFromValues(vrt.y,light.position.y);            this.lightBoundZ.setFromValues(vrt.z,light.position.z);                // any hits?            hit=false;            for (k=0;k!==map.meshList.meshes.length;k++) {                mesh=map.meshList.meshes[k];                                    // hand inlined this from mesh.boxBoundCollision                    // do x/z first because of more x/z nature of maps as                    // this should be the earliest eliminations                                    if ((mesh.xBound.min>=this.lightBoundX.max) || (mesh.xBound.max<=this.lightBoundX.min)) continue;                if ((mesh.zBound.min>=this.lightBoundZ.max) || (mesh.zBound.max<=this.lightBoundZ.min)) continue;                if ((mesh.yBound.min>=this.lightBoundY.max) || (mesh.yBound.max<=this.lightBoundY.min)) continue;                    // do all the trigs                                    trigCount=mesh.trigCount;                for (p=0;p!==trigCount;p++) {                    this.getMeshTriangleVertexes(mesh,p,this.tt0,this.tt1,this.tt2,null);                                        if (this.rayTraceTriangle(vrt,this.lightVector,this.tt0,this.tt1,this.tt2)) {                        hit=true;                        //this.lastBlockList[lightIdx].meshIdx=light.meshIntersectList[k];                        //this.lastBlockList[lightIdx].cacheTrigIdx=p;                        break;                    }                }                if (hit) break;            }                // if a hit, don't add in light            if (hit) continue;                // get the color, attenuate                // it and add it to base color            att=1.0-(dist*light.invertIntensity);            att+=Math.pow(att,light.exponent);            col.addAttenuate(light.color,att);        }        col.fixOverflow();    }            //        // render shadowmap for mesh and triangle        //    renderTriangle(shadowmap,meshIdx,v0,v1,v2,normal,t0,t1,t2)    {        let n,x,y,lx,rx,ty,by,pIdx;        let tlx,blx,trx,brx;        let dist,blackCheck;        let mesh,light,lightList;        let map=this.core.map;        let pixelData=shadowmap.pixelData;                mesh=map.meshList.meshes[meshIdx];                    // create a light list to check the            // triangle against                lightList=[];        for (n=0;n!==map.lightList.lights.length;n++) {            light=map.lightList.lights[n];            if (light.ambient) continue;                            // eliminate for distance                            dist=light.position.distance(v0);            if (dist>light.intensity) continue;                // check all the vertex normals                // only eliminate if all vertexes are                // behind/*              this.lightVectorNormal.setFromValues((light.position.x-v0.x),(light.position.y-v0.y),(light.position.z-v0.z));            this.lightVectorNormal.normalize();            if (this.lightVectorNormal.dot(normal)>=0.0) {                lightList.push(light);                continue;            }                        this.lightVectorNormal.setFromValues((light.position.x-v1.x),(light.position.y-v1.y),(light.position.z-v1.z));            this.lightVectorNormal.normalize();            if (this.lightVectorNormal.dot(normal)>=0.0) {                lightList.push(light);                continue;            }                        this.lightVectorNormal.setFromValues((light.position.x-v2.x),(light.position.y-v2.y),(light.position.z-v2.z));            this.lightVectorNormal.normalize();            if (this.lightVectorNormal.dot(normal)>=0.0) {                lightList.push(light);                continue;            }                */                              lightList.push(light);        }                if (lightList.length===0) return(false);                    // flag to see if we only wrote black pixels                    blackCheck=0.0;                    // create a transformation matrix to get            // the 2d triangle to the 3d one            // the transform matrix is [3d points]*invert([2d point])                    this.mat2d.fromArray([t0.x,t0.y,0,1,t1.x,t1.y,0,1,t2.x,t2.y,0,1,1,1,1,1]);        this.mat2dInvert.setFromInvertMatrix(this.mat2d);        this.mat3d.fromArray([v0.x,v0.y,v0.z,1,v1.x,v1.y,v1.z,1,v2.x,v2.y,v2.z,1,1,1,1,1]);        this.transformMat.setFromMultiply(this.mat3d,this.mat2dInvert);                    // render the triangle                    if (t0.y===t1.y) {            ty=t0.y;            by=t2.y;                        tlx=blx=t0.x;            trx=t1.x;            brx=t2.x;        }        else {            ty=t0.y;            by=t1.y;                        tlx=t0.x;            blx=t2.x;            trx=brx=t0.x;        }                for (y=ty;y<by;y++) {            lx=tlx+Math.trunc(((blx-tlx)*(y-ty))/(by-ty));            rx=trx+Math.trunc(((brx-trx)*(y-ty))/(by-ty));                        pIdx=((y*shadowmap.imgData.width)+lx)*4;                            for (x=lx;x<rx;x++) {                            // ray trace the 3d pixel                                this.rayPoint.setFromValues(x,y,0);                    this.rayPoint.matrixMultiply(this.transformMat);                                this.rayTraceMap(lightList,this.rayPoint,this.rayTraceVertexColor);                                pixelData[pIdx++]=this.rayTraceVertexColor.r*255.0;                pixelData[pIdx++]=this.rayTraceVertexColor.g*255.0;                pixelData[pIdx++]=this.rayTraceVertexColor.b*255.0;                pixelData[pIdx++]=255;                                    // check if we only wrote black                                    blackCheck+=(this.rayTraceVertexColor.r+this.rayTraceVertexColor.g+this.rayTraceVertexColor.b);            }        }                return(blackCheck===0.0);    }    renderMesh(meshIdx)    {        let n,allBlack,shadowmapIdx;        let vertexShadowArray,uvShadowArray;        let mesh,shadowmap;        let map=this.core.map;                mesh=map.meshList.meshes[meshIdx];                console.info(meshIdx+'/'+map.meshList.meshes.length);                    // we use regular arrays so we            // can do push, converting them to            // floats at the end                    vertexShadowArray=[];        uvShadowArray=[];                    // we want to put the entire mesh into            // one shadowmap, so find a shadow map that            // has the room        shadowmapIdx=-1;        for (n=0;n!==this.shadowmapList.length;n++) {            if ((this.LIGHTMAP_CHUNK_PER_TEXTURE-this.shadowmapList[n].chunkIdx)>mesh.trigCount) {                shadowmapIdx=n;                break;            }        }            // if we didn't find a shadowmap, make a new one        if (shadowmapIdx===-1) {            shadowmapIdx=this.shadowmapList.length;            this.shadowmapList.push(new ShadowmapBitmapClass(this));        }                    // run through the triangles            // if no lights hit a triangle, it's            // autoset to chunk 0, the all black trig                    shadowmap=this.shadowmapList[shadowmapIdx];                let color=new ColorClass(Math.random(),Math.random(),Math.random());        for (n=0;n!==mesh.trigCount;n++) {                            // get vertexes for the 3D world triangle                // and a single normal                            this.getMeshTriangleVertexes(mesh,n,this.v0,this.v1,this.v2,this.normal);                // and the vertexes for the 2D chunk shadowmap            shadowmap.getChunkCoordinates(shadowmap.chunkIdx,this.t0,this.t1,this.t2);                            // render the triangle                            allBlack=this.renderTriangle(shadowmap,mesh,this.v0,this.v1,this.v2,this.normal,this.t0,this.t1,this.t2);            //shadowmap.fillChunk(shadowmap.chunkIdx,color);            // supergumba -- testing            //                 // advance chunk if not all black (which means                // we used a chunk instead of the default all black chunk                        if (!allBlack) {                shadowmap.chunkIdx++;            }            else {                shadowmap.getChunkCoordinates(0,this.t0,this.t1,this.t2);            }                            // add the shadow map pass triangle                            //shadowmap.getChunkCoordinates((n%2),this.t0,this.t1,this.t2);    // supergumba -- testing                            vertexShadowArray.push(this.v0.x,this.v0.y,this.v0.z);            uvShadowArray.push((this.t0.x/this.LIGHTMAP_TEXTURE_SIZE),(this.t0.y/this.LIGHTMAP_TEXTURE_SIZE));                    vertexShadowArray.push(this.v1.x,this.v1.y,this.v1.z);            uvShadowArray.push((this.t1.x/this.LIGHTMAP_TEXTURE_SIZE),(this.t1.y/this.LIGHTMAP_TEXTURE_SIZE));                    vertexShadowArray.push(this.v2.x,this.v2.y,this.v2.z);            uvShadowArray.push((this.t2.x/this.LIGHTMAP_TEXTURE_SIZE),(this.t2.y/this.LIGHTMAP_TEXTURE_SIZE));        }                    // now add the vertex and uvs                    mesh.vertexShadowArray=new Float32Array(vertexShadowArray);        mesh.uvShadowArray=new Float32Array(uvShadowArray);            // map meshes have a temporary index for            // the light map.  we don't create the light            // maps into the very end (as they can be shared)            // so this is used for tracking it until than                    this.meshShadowMapIndex[meshIdx]=shadowmapIdx;            // move on to next mesh            // if out of mesh, finish up creation        meshIdx++;        if (meshIdx>=this.core.map.meshList.meshes.length) {            setTimeout(this.createFinish.bind(this),1);            return;        }            // next mesh        setTimeout(this.renderMesh.bind(this,meshIdx),1);    }            //        // create shadowmaps        // creation has to be done by a timer because this        // is too slow and browsers will bounce the script        //    create()    {        let n;        let map=this.core.map;        let nMesh=map.meshList.meshes.length;                this.debugTimestamp=Date.now();                    // run through the meshes and build            // cache to speed up ray tracing        for (n=0;n!==nMesh;n++) {        //    map.meshes[n].buildTrigRayTraceCache();        }                    // now build the last block list, which            // is used to optimize ray collisions                    for (n=0;n!==map.lightList.lights.length;n++) {        //    this.lastBlockList.push(new ShadowmapLastBlockClass());        }                    // run through the meshes            // on a timer        setTimeout(this.renderMesh.bind(this,0),1);    }    createFinish()    {        let n;        let map=this.core.map;                console.info('total maps='+this.shadowmapList.length);                    // put all the pixel data back in            // the canvases                    for (n=0;n!==this.shadowmapList.length;n++) {            this.shadowmapList[n].finish();        }                    // and set shadow maps to the meshes                    for (n=0;n!==map.meshList.meshes.length;n++) {            map.meshList.meshes[n].shadowmap=this.shadowmapList[this.meshShadowMapIndex[n]].bitmap;        }                //this.debugShadowmapBitmap(this.shadowmapList[0]);                console.info('time='+(Date.now()-this.debugTimestamp));            // finish with the callback        this.callbackFunc();    }                //        // quick debugging function        //            debugShadowmapBitmap(shadowmapBitmap)    {        let debugCanvas=document.createElement('canvas');        debugCanvas.style.position='absolute';        debugCanvas.style.left='0px';        debugCanvas.style.top='0px';        debugCanvas.style.zIndex=1000;        debugCanvas.style.touchAction='none';        debugCanvas.width=this.LIGHTMAP_TEXTURE_SIZE;        debugCanvas.height=this.LIGHTMAP_TEXTURE_SIZE;        document.body.appendChild(debugCanvas);        debugCanvas.getContext('2d').drawImage(shadowmapBitmap.canvas,0,0);    }}