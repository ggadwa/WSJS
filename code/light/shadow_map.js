import PointClass from '../utility/point.js';import BoundClass from '../utility/bound.js';import ColorClass from '../utility/color.js';import Matrix4Class from '../utility/matrix4.js';//// shadowmap bitmap class// records each generated shadowmap// canvas and the last chunk written to//class ShadowmapBitmapClass{    constructor(shadowmapGenerator)    {        let n;                this.shadowmapGenerator=shadowmapGenerator;                    // some constants                this.shadowMapSize=shadowmapGenerator.SHADOWMAP_TEXTURE_SIZE;        this.chunkSize=shadowmapGenerator.SHADOWMAP_CHUNK_SIZE;        this.chunkPerRow=Math.trunc(shadowmapGenerator.SHADOWMAP_TEXTURE_SIZE/this.chunkSize);                    // the final bitmap                    this.bitmap=null;            // the luminosity data        this.lumData=new Float32Array(shadowmapGenerator.SHADOWMAP_TEXTURE_SIZE*shadowmapGenerator.SHADOWMAP_TEXTURE_SIZE);            // clear to min shadow color        for (n=0;n!==(shadowmapGenerator.SHADOWMAP_TEXTURE_SIZE*shadowmapGenerator.SHADOWMAP_TEXTURE_SIZE);n++) {            this.lumData[n]=shadowmapGenerator.SHADOW_MIN_VALUE;        }            // the first chunk is always the            // "all black" chunk so we start at chunk 1                    this.chunkIdx=1;                Object.seal(this);    }            //        // chunk utilities        //            getChunkCoordinates(cIdx,p0,p1,p2)    {        let x,y;        let secondTrig;                secondTrig=cIdx%2;        cIdx=cIdx>>1;                x=(cIdx%this.chunkPerRow)*this.chunkSize;        y=Math.trunc(cIdx/this.chunkPerRow)*this.chunkSize;                if (!secondTrig) {            p0.setFromValues(x,y,0);            p1.setFromValues((x+this.chunkSize),y,0);            p2.setFromValues(x,(y+this.chunkSize),0);        }        else {            p0.setFromValues((x+this.chunkSize),y,0);            p1.setFromValues((x+this.chunkSize),(y+this.chunkSize),0);            p2.setFromValues(x,(y+this.chunkSize),0);        }    }        fillChunk(cIdx,lum)    {        let pIdx;        let x,y,ty,by,lx,rx,tlx,blx,trx,brx;                this.getChunkCoordinates(cIdx,this.t0,this.t1,this.t2);                if (this.t0.y===this.t1.y) {            ty=this.t0.y;            by=this.t2.y;                        tlx=blx=this.t0.x;            trx=this.t1.x;            brx=this.t2.x;        }        else {            ty=this.t0.y;            by=this.t1.y;                        tlx=this.t0.x;            blx=this.t2.x;            trx=brx=this.t0.x;        }                for (y=ty;y<by;y++) {            lx=tlx+Math.trunc(((blx-tlx)*(y-ty))/(by-ty));            rx=trx+Math.trunc(((brx-trx)*(y-ty))/(by-ty));                        pIdx=(y*this.shadowMapSize)+lx;                            for (x=lx;x<rx;x++) {                this.lumData[pIdx++]=lum;            }        }    }            //        // create a bitmap from the data        //    finish()    {        let n;        let canvas,ctx;        let imgData,pIdx,pixel;                canvas=document.createElement('canvas');        canvas.width=this.shadowMapSize;        canvas.height=this.shadowMapSize;                ctx=canvas.getContext('2d');        imgData=ctx.getImageData(0,0,this.shadowMapSize,this.shadowMapSize);                pIdx=0;                for (n=0;n!==(this.shadowMapSize*this.shadowMapSize);n++) {            pixel=this.lumData[n]*255.0;            imgData.data[pIdx++]=pixel;            imgData.data[pIdx++]=pixel;            imgData.data[pIdx++]=pixel;            imgData.data[pIdx++]=255;        }                canvas.getContext('2d').putImageData(imgData,0,0);                this.bitmap=this.shadowmapGenerator.core.bitmapList.addShadowmap(canvas);    }}//// this object contains one of the lights in the scene,// plus a list of all it's collision meshes to speed// up the tracing//class ShadowmapLightClass{    constructor(core,mapLight)    {        this.core=core;        this.position=mapLight.position;        this.intensity=mapLight.intensity;        this.invertIntensity=mapLight.invertIntensity;        this.exponent=mapLight.exponent;                    // some ray trace optimization values                    this.lastBlockMeshIdx=-1;        this.lastBlockTriangleIdx=-1;            // all the meshes that collide with            // the light globe                    this.collideMeshes=[];    }        calculateCollisionList()    {        let n;                    }}//// generate shadow map class//export default class ShadowmapGeneratorClass{    constructor(core,callbackFunc)    {        this.core=core;        this.callbackFunc=callbackFunc;                this.debugTimestamp=0;                    // constants                    this.SHADOWMAP_TEXTURE_SIZE=1024;        this.SHADOWMAP_CHUNK_SPLIT=16;                  // how many chunks in both the X and Y direction        this.SHADOWMAP_CHUNK_SIZE=Math.trunc(this.SHADOWMAP_TEXTURE_SIZE/this.SHADOWMAP_CHUNK_SPLIT);    // square pixel size of chunks        this.SHADOWMAP_CHUNK_PER_TEXTURE=(this.SHADOWMAP_CHUNK_SPLIT*this.SHADOWMAP_CHUNK_SPLIT)*2;        // how many chunks in a single texture        this.SHADOW_MIN_VALUE=0.5;            // array of bitmaps that make up the shadowmaps            // each is an object with a canvas and the last chunk            // drawn to (the chunkIdx)        this.shadowmapList=[];                    // to track which shadowmap each mesh is in                    this.meshShadowMapIndex=new Int16Array(this.core.map.meshList.meshes.length);            // lights in ray trace                    this.lights=[];            // some pre-allocates                    this.lightVector=new PointClass(0,0,0);        this.lightVectorNormal=new PointClass(0,0,0);                this.lightBoundX=new BoundClass(0,0);        this.lightBoundY=new BoundClass(0,0);        this.lightBoundZ=new BoundClass(0,0);                    this.v0=new PointClass(0,0,0);      // the 3D triangle in the map        this.v1=new PointClass(0,0,0);        this.v2=new PointClass(0,0,0);                this.normal=new PointClass(0,0,0);  // a single normal to eliminate lights                this.t0=new PointClass(0,0,0);      // the 2D shadow map projection        this.t1=new PointClass(0,0,0);        this.t2=new PointClass(0,0,0);                this.mat2d=new Matrix4Class();      // these are used to create a transformation matrix from 2D render to 3D triangle        this.mat2dInvert=new Matrix4Class();        this.mat3d=new Matrix4Class();        this.transformMat=new Matrix4Class();                this.rayPoint=new PointClass(0,0,0);        this.rayTraceVertexColor=new ColorClass(0,0,0);                this.v10=new PointClass(0,0,0);        this.v20=new PointClass(0,0,0);                this.tt0=new PointClass(0,0,0);        this.tt1=new PointClass(0,0,0);        this.tt2=new PointClass(0,0,0);                Object.seal(this);    }        getMeshTriangleVertexes(mesh,tIdx,v0,v1,v2,normal)    {        let vIdx;                tIdx*=3;        vIdx=mesh.indexArray[tIdx]*3;        v0.setFromValues(mesh.vertexArray[vIdx],mesh.vertexArray[vIdx+1],mesh.vertexArray[vIdx+2]);        if (normal!==null) normal.setFromValues(mesh.normalArray[vIdx],mesh.normalArray[vIdx+1],mesh.normalArray[vIdx+2]);                vIdx=mesh.indexArray[tIdx+1]*3;        v1.setFromValues(mesh.vertexArray[vIdx],mesh.vertexArray[vIdx+1],mesh.vertexArray[vIdx+2]);                vIdx=mesh.indexArray[tIdx+2]*3;        v2.setFromValues(mesh.vertexArray[vIdx],mesh.vertexArray[vIdx+1],mesh.vertexArray[vIdx+2]);    }            //        // ray tracing        //    rayTraceTriangle(vrt,vct,t0,t1,t2)    {        let perpVectorX,perpVectorY,perpVectorZ;        let det,invDet,u,v;        let lineToTrigPointVectorX,lineToTrigPointVectorY,lineToTrigPointVectorZ;        let lineToTrigPerpVectorX,lineToTrigPerpVectorY,lineToTrigPerpVectorZ;                    // vrt = point to ray trace            // v10[x,y,z]=t1[x,y,z]-t0[x,y,z]            // v20[x,y,z]=t2[x,y,z]-t0[x,y,z]                this.v10.setFromSubPoint(t1,t0);        this.v20.setFromSubPoint(t2,t0);            // calculate the determinate            // perpVector is cross(vector,v2)            // det is dot(v1,perpVector)        perpVectorX=(vct.y*this.v20.z)-(vct.z*this.v20.y);        perpVectorY=(vct.z*this.v20.x)-(vct.x*this.v20.z);        perpVectorZ=(vct.x*this.v20.y)-(vct.y*this.v20.x);        det=(this.v10.x*perpVectorX)+(this.v10.y*perpVectorY)+(this.v10.z*perpVectorZ);            // is line on the same plane as triangle?        if ((det>-0.00001) && (det<0.00001)) return(false);            // get the inverse determinate        invDet=1.0/det;            // calculate triangle U and test            // lineToTrigPointVector is vector from vertex to triangle point 0            // u is invDet * dot(lineToTrigPointVector,perpVector)        lineToTrigPointVectorX=vrt.x-t0.x;        lineToTrigPointVectorY=vrt.y-t0.y;        lineToTrigPointVectorZ=vrt.z-t0.z;        u=invDet*((lineToTrigPointVectorX*perpVectorX)+(lineToTrigPointVectorY*perpVectorY)+(lineToTrigPointVectorZ*perpVectorZ));        if ((u<0.0) || (u>1.0)) return(false);            // calculate triangle V and test            // lineToTrigPerpVector is cross(lineToTrigPointVector,v1)            // v is invDet * dot(vector,lineToTrigPerpVector)        lineToTrigPerpVectorX=(lineToTrigPointVectorY*this.v10.z)-(lineToTrigPointVectorZ*this.v10.y);        lineToTrigPerpVectorY=(lineToTrigPointVectorZ*this.v10.x)-(lineToTrigPointVectorX*this.v10.z);        lineToTrigPerpVectorZ=(lineToTrigPointVectorX*this.v10.y)-(lineToTrigPointVectorY*this.v10.x);        v=invDet*((vct.x*lineToTrigPerpVectorX)+(vct.y*lineToTrigPerpVectorY)+(vct.z*lineToTrigPerpVectorZ));        if ((v<0.0) || ((u+v)>1.0)) return(false);            // t is the point on the line, from the            // invDet*dot(v2,lineToTrigPerpVector)            // this is a little different then normal ray trace            // hits, we add in an extra 0.01 slop so polygons that are            // touching each other don't have edges grayed in        let t=invDet*((this.v20.x*lineToTrigPerpVectorX)+(this.v20.y*lineToTrigPerpVectorY)+(this.v20.z*lineToTrigPerpVectorZ));        return((t>0.01)&&(t<1.0));    }    rayTraceMap(lightList,vrt)    {        let n,nLight,trigCount;        let light,lum;        let k,p,hit,mesh;        let dist,att;        let map=this.core.map;        let nMesh=map.meshList.meshes.length;                    // start with min light                    lum=this.SHADOW_MIN_VALUE;                    // we use the passed in light list which is a cut down            // list precalculcated from mesh/light interactions and            // removing any lights that are facing away from the            // front side of the triangle        nLight=lightList.length;        for (n=0;n!==nLight;n++) {            light=lightList[n];                // light within light range?            dist=light.position.distance(vrt);            if (dist>light.intensity) continue;                // vector from render point to light            this.lightVector.setFromSubPoint(light.position,vrt);                // we keep a list of the last mesh                // to block a light and we check that first                // because a lot of the time the same mesh will come                // up rendering a triangle in a mesh               if (light.lastBlockMeshIdx!==-1) {                mesh=map.meshList.meshes[light.lastBlockMeshIdx];                                this.getMeshTriangleVertexes(mesh,light.lastBlockTriangleIdx,this.tt0,this.tt1,this.tt2,null);                if (this.rayTraceTriangle(vrt,this.lightVector,this.tt0,this.tt1,this.tt2)) continue;            }                // light bounding            this.lightBoundX.setFromValues(vrt.x,light.position.x);            this.lightBoundY.setFromValues(vrt.y,light.position.y);            this.lightBoundZ.setFromValues(vrt.z,light.position.z);                // any hits?            hit=false;            for (k=0;k!==nMesh;k++) {                mesh=map.meshList.meshes[k];                                    // hand inlined this from mesh.boxBoundCollision                    // do x/z first because of more x/z nature of maps as                    // this should be the earliest eliminations                                    if ((mesh.xBound.min>=this.lightBoundX.max) || (mesh.xBound.max<=this.lightBoundX.min)) continue;                if ((mesh.zBound.min>=this.lightBoundZ.max) || (mesh.zBound.max<=this.lightBoundZ.min)) continue;                if ((mesh.yBound.min>=this.lightBoundY.max) || (mesh.yBound.max<=this.lightBoundY.min)) continue;                    // do all the trigs                                    trigCount=mesh.trigCount;                for (p=0;p!==trigCount;p++) {                    this.getMeshTriangleVertexes(mesh,p,this.tt0,this.tt1,this.tt2,null);                                        if (this.rayTraceTriangle(vrt,this.lightVector,this.tt0,this.tt1,this.tt2)) {                        hit=true;                        light.lastBlockMeshIdx=k;                        light.lastBlockTriangleIdx=p;                        break;                    }                }                if (hit) break;            }                // if no hit, then we aren't in shadow            if (hit) continue;                // attenuate to get the lum value            att=1.0-(dist*light.invertIntensity);            lum+=(att+Math.pow(att,light.exponent));        }                return(lum);    }            //        // render shadowmap for mesh and triangle        //    renderTriangle(shadowmap,meshIdx,v0,v1,v2,normal,t0,t1,t2)    {        let n,x,y,lx,rx,ty,by,pIdx;        let tlx,blx,trx,brx;        let dist,lum,allBlack;        let mesh,light,lightList;        let map=this.core.map;        let lumData=shadowmap.lumData;                mesh=map.meshList.meshes[meshIdx];                    // create a light list to check the            // triangle against                lightList=[];        for (n=0;n!==this.lights.length;n++) {            light=this.lights[n];                            // eliminate for distance                            dist=light.position.distance(v0);            if (dist>light.intensity) continue;                // check all the vertex normals                // only eliminate if all vertexes are                // behind              this.lightVectorNormal.setFromValues((light.position.x-v0.x),(light.position.y-v0.y),(light.position.z-v0.z));            this.lightVectorNormal.normalize();            if (this.lightVectorNormal.dot(normal)>=0.0) {                lightList.push(light);                continue;            }                        this.lightVectorNormal.setFromValues((light.position.x-v1.x),(light.position.y-v1.y),(light.position.z-v1.z));            this.lightVectorNormal.normalize();            if (this.lightVectorNormal.dot(normal)>=0.0) {                lightList.push(light);                continue;            }                        this.lightVectorNormal.setFromValues((light.position.x-v2.x),(light.position.y-v2.y),(light.position.z-v2.z));            this.lightVectorNormal.normalize();            if (this.lightVectorNormal.dot(normal)>=0.0) {                lightList.push(light);                continue;            }                           //   lightList.push(light);        }                    // if no lights, it's all black                    if (lightList.length===0) return(true);                    // flag to see if we only wrote black lum values                    allBlack=true;                    // create a transformation matrix to get            // the 2d triangle to the 3d one            // the transform matrix is [3d points]*invert([2d point])                    this.mat2d.fromArray([t0.x,t0.y,0,1,t1.x,t1.y,0,1,t2.x,t2.y,0,1,1,1,1,1]);        this.mat2dInvert.setFromInvertMatrix(this.mat2d);        this.mat3d.fromArray([v0.x,v0.y,v0.z,1,v1.x,v1.y,v1.z,1,v2.x,v2.y,v2.z,1,1,1,1,1]);        this.transformMat.setFromMultiply(this.mat3d,this.mat2dInvert);                    // render the triangle                    if (t0.y===t1.y) {            ty=t0.y;            by=t2.y;                        tlx=blx=t0.x;            trx=t1.x;            brx=t2.x;        }        else {            ty=t0.y;            by=t1.y;                        tlx=t0.x;            blx=t2.x;            trx=brx=t0.x;        }                for (y=ty;y<by;y++) {            lx=tlx+Math.trunc(((blx-tlx)*(y-ty))/(by-ty));            rx=trx+Math.trunc(((brx-trx)*(y-ty))/(by-ty));                        pIdx=(y*this.SHADOWMAP_TEXTURE_SIZE)+lx;                            for (x=lx;x<rx;x++) {                            // ray trace the 3d pixel                                this.rayPoint.setFromValues(x,y,0);                    this.rayPoint.matrixMultiply(this.transformMat);                                lum=this.rayTraceMap(lightList,this.rayPoint);                                if (lum>this.SHADOW_MIN_VALUE) {                    lumData[pIdx]=lum;                    allBlack=false;                }                                pIdx++;            }        }                return(allBlack);    }    renderMesh(meshIdx)    {        let n,allBlack,shadowmapIdx;        let vertexShadowArray,uvShadowArray;        let mesh,shadowmap;        let map=this.core.map;                mesh=map.meshList.meshes[meshIdx];                console.info(meshIdx+'/'+map.meshList.meshes.length);                    // we use regular arrays so we            // can do push, converting them to            // floats at the end                    vertexShadowArray=[];        uvShadowArray=[];                    // we want to put the entire mesh into            // one shadowmap, so find a shadow map that            // has the room        shadowmapIdx=-1;        for (n=0;n!==this.shadowmapList.length;n++) {            if ((this.SHADOWMAP_CHUNK_PER_TEXTURE-this.shadowmapList[n].chunkIdx)>mesh.trigCount) {                shadowmapIdx=n;                break;            }        }            // if we didn't find a shadowmap, make a new one        if (shadowmapIdx===-1) {            shadowmapIdx=this.shadowmapList.length;            this.shadowmapList.push(new ShadowmapBitmapClass(this));        }                    // run through the triangles            // if no lights hit a triangle, it's            // autoset to chunk 0, the all black trig                    shadowmap=this.shadowmapList[shadowmapIdx];                for (n=0;n!==mesh.trigCount;n++) {                            // get vertexes for the 3D world triangle                // and a single normal                            this.getMeshTriangleVertexes(mesh,n,this.v0,this.v1,this.v2,this.normal);                // and the vertexes for the 2D chunk shadowmap            shadowmap.getChunkCoordinates(shadowmap.chunkIdx,this.t0,this.t1,this.t2);                            // render the triangle                            allBlack=this.renderTriangle(shadowmap,mesh,this.v0,this.v1,this.v2,this.normal,this.t0,this.t1,this.t2);                 // advance chunk if not all black (which means                // we used a chunk instead of the default all black chunk                        if (!allBlack) {                shadowmap.chunkIdx++;            }            else {                shadowmap.getChunkCoordinates(0,this.t0,this.t1,this.t2);            }                            // add the shadow map pass triangle                            vertexShadowArray.push(this.v0.x,this.v0.y,this.v0.z);            uvShadowArray.push((this.t0.x/this.SHADOWMAP_TEXTURE_SIZE),(this.t0.y/this.SHADOWMAP_TEXTURE_SIZE));                    vertexShadowArray.push(this.v1.x,this.v1.y,this.v1.z);            uvShadowArray.push((this.t1.x/this.SHADOWMAP_TEXTURE_SIZE),(this.t1.y/this.SHADOWMAP_TEXTURE_SIZE));                    vertexShadowArray.push(this.v2.x,this.v2.y,this.v2.z);            uvShadowArray.push((this.t2.x/this.SHADOWMAP_TEXTURE_SIZE),(this.t2.y/this.SHADOWMAP_TEXTURE_SIZE));        }                    // now add the vertex and uvs                    mesh.vertexShadowArray=new Float32Array(vertexShadowArray);        mesh.uvShadowArray=new Float32Array(uvShadowArray);            // map meshes have a temporary index for            // the light map.  we don't create the light            // maps into the very end (as they can be shared)            // so this is used for tracking it until than                    this.meshShadowMapIndex[meshIdx]=shadowmapIdx;            // move on to next mesh            // if out of mesh, finish up creation        meshIdx++;        if (meshIdx>=this.core.map.meshList.meshes.length) {            setTimeout(this.createFinish.bind(this),1);            return;        }            // next mesh        setTimeout(this.renderMesh.bind(this,meshIdx),1);    }            //        // create shadowmaps        // creation has to be done by a timer because this        // is too slow and browsers will bounce the script        //    create()    {        let n,light,effect;        let map=this.core.map;                this.debugTimestamp=Date.now();                    // build a list of lights for the            // scene that have mesh collisions                    this.lights=[];                for (n=0;n!==map.lightList.lights.length;n++) {            light=new ShadowmapLightClass(this.core,map.lightList.lights[n]);            light.calculateCollisionList();            this.lights.push(light);        }                for (n=0;n!==map.effectList.effects.length;n++) {            effect=map.effectList.effects[n];            if (effect.light===null) continue;                        light=new ShadowmapLightClass(this.core,effect.light);            light.calculateCollisionList();            this.lights.push(light);        }                    // run through the meshes            // on a timer        setTimeout(this.renderMesh.bind(this,0),1);    }    createFinish()    {        let n;        let map=this.core.map;                console.info('total maps='+this.shadowmapList.length);                    // put all the pixel data back in            // the canvases                    for (n=0;n!==this.shadowmapList.length;n++) {            this.shadowmapList[n].finish();        }                    // and set shadow maps to the meshes                    for (n=0;n!==map.meshList.meshes.length;n++) {            map.meshList.meshes[n].shadowmap=this.shadowmapList[this.meshShadowMapIndex[n]].bitmap;        }                //this.debugShadowmapBitmap(this.shadowmapList[0]);                console.info('time='+(Date.now()-this.debugTimestamp));            // finish with the callback        this.callbackFunc();    }            //        // quick debugging function        //            debugShadowmapBitmap(shadowmapBitmap)    {        let n,pIdx,pixel;        let debugCanvas,ctx;        let imgData;                debugCanvas=document.createElement('canvas');        debugCanvas.style.position='absolute';        debugCanvas.style.left='0px';        debugCanvas.style.top='0px';        debugCanvas.style.zIndex=1000;        debugCanvas.style.touchAction='none';        debugCanvas.width=this.SHADOWMAP_TEXTURE_SIZE;        debugCanvas.height=this.SHADOWMAP_TEXTURE_SIZE;        document.body.appendChild(debugCanvas);                ctx=debugCanvas.getContext('2d');        imgData=ctx.getImageData(0,0,this.SHADOWMAP_TEXTURE_SIZE,this.SHADOWMAP_TEXTURE_SIZE);                pIdx=0;                for (n=0;n!==(this.SHADOWMAP_TEXTURE_SIZE*this.SHADOWMAP_TEXTURE_SIZE);n++) {            pixel=shadowmapBitmap.lumData[n]*255.0;            imgData.data[pIdx++]=pixel;            imgData.data[pIdx++]=pixel;            imgData.data[pIdx++]=pixel;            imgData.data[pIdx++]=255;        }                debugCanvas.getContext('2d').putImageData(imgData,0,0);    }}