<!DOCTYPE HTML>

<html>

<head>
<meta charset="utf-8">
<title>WSJS</title>

<!-- the scripts -->

<script type="text/javascript" src="code/main/settings.js" charset="utf-8"></script>
<script type="text/javascript" src="code/main/defs.js" charset="utf-8"></script>
<script type="text/javascript" src="code/main/shader.js" charset="utf-8"></script>
<script type="text/javascript" src="code/main/bitmap.js" charset="utf-8"></script>
<script type="text/javascript" src="code/main/debug.js" charset="utf-8"></script>
<script type="text/javascript" src="code/main/debug_shader.js" charset="utf-8"></script>
<script type="text/javascript" src="code/main/view.js" charset="utf-8"></script>
<script type="text/javascript" src="code/main/input.js" charset="utf-8"></script>
<script type="text/javascript" src="code/map/map.js" charset="utf-8"></script>
<script type="text/javascript" src="code/map/map_shader.js" charset="utf-8"></script>
<script type="text/javascript" src="code/map/map_lightmap.js" charset="utf-8"></script>
<script type="text/javascript" src="code/map/map_mesh.js" charset="utf-8"></script>
<script type="text/javascript" src="code/map/map_light.js" charset="utf-8"></script>
<script type="text/javascript" src="code/model/model_list.js" charset="utf-8"></script>
<script type="text/javascript" src="code/model/model.js" charset="utf-8"></script>
<script type="text/javascript" src="code/model/model_skeleton.js" charset="utf-8"></script>
<script type="text/javascript" src="code/model/model_mesh.js" charset="utf-8"></script>
<script type="text/javascript" src="code/model/model_shader.js" charset="utf-8"></script>
<script type="text/javascript" src="code/entities/collisions.js" charset="utf-8"></script>
<script type="text/javascript" src="code/entities/entity.js" charset="utf-8"></script>
<script type="text/javascript" src="code/entities/entity_list.js" charset="utf-8"></script>
<script type="text/javascript" src="code/text/text.js" charset="utf-8"></script>
<script type="text/javascript" src="code/text/text_shader.js" charset="utf-8"></script>
<script type="text/javascript" src="code/interface/interface.js" charset="utf-8"></script>
<script type="text/javascript" src="code/interface/interface_shader.js" charset="utf-8"></script>
<script type="text/javascript" src="generate/utility/random.js" charset="utf-8"></script>
<script type="text/javascript" src="generate/utility/mesh_uv_tangents.js" charset="utf-8"></script>
<script type="text/javascript" src="generate/utility/mesh_primitives.js" charset="utf-8"></script>
<script type="text/javascript" src="generate/bitmap/gen_bitmap_util.js" charset="utf-8"></script>
<script type="text/javascript" src="generate/bitmap/gen_bitmap.js" charset="utf-8"></script>
<script type="text/javascript" src="generate/map/gen_map_pieces.js" charset="utf-8"></script>
<script type="text/javascript" src="generate/map/gen_map.js" charset="utf-8"></script>
<script type="text/javascript" src="generate/map/gen_map_stair.js" charset="utf-8"></script>
<script type="text/javascript" src="generate/map/gen_map_decoration.js" charset="utf-8"></script>
<script type="text/javascript" src="generate/map/gen_light_map.js" charset="utf-8"></script>
<script type="text/javascript" src="generate/model/gen_skeleton.js" charset="utf-8"></script>
<script type="text/javascript" src="generate/model/gen_model_mesh.js" charset="utf-8"></script>
<script type="text/javascript" src="code/main/main.js" charset="utf-8"></script>

<!-- the shaders -->
<!-- I hate doing it this way, but origin security stops me from using iframes for this -->
<!-- otherwise I'd just make an iframe, load the source from file, and read it contentWindow.document.etc -->

<!-- NOTE!  lightType has two vec4 instead of vec3, this is to work around a windows bug.  Fix later when bug is fixed -->

<script id="wsMapVertShader" type="x-shader/x-vertex">    
    attribute highp vec3 vertexPosition;
    attribute highp vec3 vertexNormal;
    attribute highp vec3 vertexTangent;
    attribute highp vec4 vertexAndLightmapUV;

    uniform highp mat4 perspectiveMatrix;
    uniform highp mat4 modelMatrix;
    uniform highp mat3 normalMatrix;

    struct lightType {
        highp vec4 position;
        lowp vec4 color;
        mediump float intensity;
        mediump float invertIntensity;
        mediump float exponent;
    };

    uniform lightType light_0;
    uniform lightType light_1;
    uniform lightType light_2;
    uniform lightType light_3;

    varying highp vec3 eyeVector;
    varying highp vec4 fragUV;

    varying highp float lightDistance_0;
    varying highp float lightDistance_1;
    varying highp float lightDistance_2;
    varying highp float lightDistance_3;

    varying highp vec3 lightVertexVector_0;
    varying highp vec3 lightVertexVector_1;
    varying highp vec3 lightVertexVector_2;
    varying highp vec3 lightVertexVector_3;

    void main(void)
    {
        highp vec3 lvct;

        gl_Position=perspectiveMatrix*modelMatrix*vec4(vertexPosition,1.0);

            // get the tangent space

        highp vec3 vtx=vec3(modelMatrix*vec4(vertexPosition,1.0));

        mediump vec3 tangentSpaceTangent=normalize(normalMatrix*vertexTangent);
        mediump vec3 tangentSpaceBinormal=normalize(normalMatrix*cross(vertexNormal,vertexTangent));
        mediump vec3 tangentSpaceNormal=normalize(normalMatrix*vertexNormal);

            // translate the eye vector

        eyeVector.x=dot(-vtx,tangentSpaceTangent);
        eyeVector.y=dot(-vtx,tangentSpaceBinormal);
        eyeVector.z=dot(-vtx,tangentSpaceNormal);

            // translate the light 0 vector

        lvct=light_0.position.xyz-vtx;
        lightDistance_0=length(lvct);

        lightVertexVector_0.x=dot(lvct,tangentSpaceTangent);
        lightVertexVector_0.y=dot(lvct,tangentSpaceBinormal);
        lightVertexVector_0.z=dot(lvct,tangentSpaceNormal);

            // translate the light 1 vector

        lvct=light_1.position.xyz-vtx;
        lightDistance_1=length(lvct);

        lightVertexVector_1.x=dot(lvct,tangentSpaceTangent);
        lightVertexVector_1.y=dot(lvct,tangentSpaceBinormal);
        lightVertexVector_1.z=dot(lvct,tangentSpaceNormal);

            // translate the light 2 vector

        lvct=light_2.position.xyz-vtx;
        lightDistance_2=length(lvct);

        lightVertexVector_2.x=dot(lvct,tangentSpaceTangent);
        lightVertexVector_2.y=dot(lvct,tangentSpaceBinormal);
        lightVertexVector_2.z=dot(lvct,tangentSpaceNormal);

            // translate the light 3 vector

        lvct=light_3.position.xyz-vtx;
        lightDistance_3=length(lvct);

        lightVertexVector_3.x=dot(lvct,tangentSpaceTangent);
        lightVertexVector_3.y=dot(lvct,tangentSpaceBinormal);
        lightVertexVector_3.z=dot(lvct,tangentSpaceNormal);

            // the varying uv

        fragUV=vertexAndLightmapUV;
    }
</script>

<script id="wsMapFragShader" type="x-shader/x-fragment">
    uniform lowp sampler2D baseTex;
    uniform lowp sampler2D normalTex;
    uniform lowp sampler2D specularTex;
    uniform lowp sampler2D lightmapTex;

    uniform lowp vec3 ambient;
    uniform mediump float shineFactor;

    struct lightType {
        highp vec4 position;
        lowp vec4 color;
        mediump float intensity;
        mediump float invertIntensity;
        mediump float exponent;
    };

    uniform lightType light_0;
    uniform lightType light_1;
    uniform lightType light_2;
    uniform lightType light_3;

    varying highp vec3 eyeVector;
    varying highp vec4 fragUV;

    varying highp float lightDistance_0;
    varying highp float lightDistance_1;
    varying highp float lightDistance_2;
    varying highp float lightDistance_3;

    varying highp vec3 lightVertexVector_0;
    varying highp vec3 lightVertexVector_1;
    varying highp vec3 lightVertexVector_2;
    varying highp vec3 lightVertexVector_3;

    void main(void)
    {
        lowp float att;

            // the ambient plus the
            // light map

        lowp vec3 pixelAmbient=texture2D(lightmapTex,fragUV.zw).rgb+ambient;

            // the texture fragment

        lowp vec4 tex=texture2D(baseTex,fragUV.xy);

            // the starting bump map
            // since it will be created by going through the
            // lights, we need a default value

        highp vec3 bumpLightVertexVector;
        lowp vec3 bumpMap=normalize((texture2D(normalTex,fragUV.xy).rgb*2.0)-1.0);
        lowp float bump=dot(vec3(0.33,0.33,0.33),bumpMap);

            // the starting spec map

        lowp vec3 spec=vec3(0.0,0.0,0.0),specHalfVector;
        lowp vec3 specMap=texture2D(specularTex,fragUV.xy).rgb;
        lowp float specFactor;

            // light 0

        if (lightDistance_0<light_0.intensity) {

                // the lighting attenuation

            att=1.0-(lightDistance_0*light_0.invertIntensity);
            att+=pow(att,light_0.exponent);
            pixelAmbient+=(light_0.color.rgb*att);

                // per-light bump calc

            bumpLightVertexVector=normalize(lightVertexVector_0);
            bump+=(dot(bumpLightVertexVector,bumpMap)*att);

                // per-light spec count

            specHalfVector=normalize(normalize(eyeVector)+bumpLightVertexVector);
            specFactor=max(dot(bumpMap,specHalfVector),0.0);
            spec+=((specMap*pow(specFactor,shineFactor))*att);
        }

            // light 1

        if (lightDistance_1<light_1.intensity) {

                // the lighting attenuation

            att=1.0-(lightDistance_1*light_1.invertIntensity);
            att+=pow(att,light_1.exponent);
            pixelAmbient+=(light_1.color.rgb*att);

                // per-light bump calc

            bumpLightVertexVector=normalize(lightVertexVector_1);
            bump+=(dot(bumpLightVertexVector,bumpMap)*att);

                // per-light spec count

            specHalfVector=normalize(normalize(eyeVector)+bumpLightVertexVector);
            specFactor=max(dot(bumpMap,specHalfVector),0.0);
            spec+=((specMap*pow(specFactor,shineFactor))*att);
        }

            // light 2

        if (lightDistance_2<light_2.intensity) {

                // the lighting attenuation

            att=1.0-(lightDistance_2*light_2.invertIntensity);
            att+=pow(att,light_2.exponent);
            pixelAmbient+=(light_2.color.rgb*att);

                // per-light bump calc

            bumpLightVertexVector=normalize(lightVertexVector_2);
            bump+=(dot(bumpLightVertexVector,bumpMap)*att);

                // per-light spec count

            specHalfVector=normalize(normalize(eyeVector)+bumpLightVertexVector);
            specFactor=max(dot(bumpMap,specHalfVector),0.0);
            spec+=((specMap*pow(specFactor,shineFactor))*att);
        }

            // light 3

        if (lightDistance_3<light_3.intensity) {

                // the lighting attenuation

            att=1.0-(lightDistance_3*light_3.invertIntensity);
            att+=pow(att,light_3.exponent);
            pixelAmbient+=(light_3.color.rgb*att);

                // per-light bump calc

            bumpLightVertexVector=normalize(lightVertexVector_3);
            bump+=(dot(bumpLightVertexVector,bumpMap)*att);

                // per-light spec count

            specHalfVector=normalize(normalize(eyeVector)+bumpLightVertexVector);
            specFactor=max(dot(bumpMap,specHalfVector),0.0);
            spec+=((specMap*pow(specFactor,shineFactor))*att);
        }

            // finish the spec by making sure
            // it's dimmed in dark areas

        spec=min(spec,1.0)*((pixelAmbient.r+pixelAmbient.g+pixelAmbient.b)*0.33);

            // add bump into the ambient and make
            // sure it's never less than 10% of the
            // ambient

        pixelAmbient=max((pixelAmbient*bump),(ambient*0.9));

            // finally create the pixel

        //gl_FragColor.rgb=texture2D(lightmapTex,fragUV.zw).rgb; // light map test
        //gl_FragColor.rgb=tex.rgb*texture2D(lightmapTex,fragUV.zw).rgb; // texture + light map test
        //gl_FragColor.rgb=tex.rgb*pixelAmbient;      // texture + light map + bump
        gl_FragColor.rgb=(tex.rgb*pixelAmbient)+spec;
        gl_FragColor.a=tex.a;
    }
</script>

<script id="wsModelVertShader" type="x-shader/x-vertex">    
    attribute highp vec3 vertexPosition;
    attribute highp vec3 vertexNormal;
    attribute highp vec3 vertexTangent;
    attribute highp vec2 vertexUV;

    uniform highp mat4 perspectiveMatrix;
    uniform highp mat4 modelMatrix;
    uniform highp mat3 normalMatrix;

    struct lightType {
        highp vec4 position;
        lowp vec4 color;
        mediump float intensity;
        mediump float invertIntensity;
        mediump float exponent;
    };

    uniform lightType light_0;
    uniform lightType light_1;
    uniform lightType light_2;
    uniform lightType light_3;

    varying highp vec3 eyeVector;
    varying highp vec2 fragUV;

    varying highp float lightDistance_0;
    varying highp float lightDistance_1;
    varying highp float lightDistance_2;
    varying highp float lightDistance_3;

    varying highp vec3 lightVertexVector_0;
    varying highp vec3 lightVertexVector_1;
    varying highp vec3 lightVertexVector_2;
    varying highp vec3 lightVertexVector_3;

    void main(void)
    {
        highp vec3 lvct;

        gl_Position=perspectiveMatrix*modelMatrix*vec4(vertexPosition,1.0);

            // get the tangent space

        highp vec3 vtx=vec3(modelMatrix*vec4(vertexPosition,1.0));

        mediump vec3 tangentSpaceTangent=normalize(normalMatrix*vertexTangent);
        mediump vec3 tangentSpaceBinormal=normalize(normalMatrix*cross(vertexNormal,vertexTangent));
        mediump vec3 tangentSpaceNormal=normalize(normalMatrix*vertexNormal);

            // translate the eye vector

        eyeVector.x=dot(-vtx,tangentSpaceTangent);
        eyeVector.y=dot(-vtx,tangentSpaceBinormal);
        eyeVector.z=dot(-vtx,tangentSpaceNormal);

            // translate the light 0 vector

        lvct=light_0.position.xyz-vtx;
        lightDistance_0=length(lvct);

        lightVertexVector_0.x=dot(lvct,tangentSpaceTangent);
        lightVertexVector_0.y=dot(lvct,tangentSpaceBinormal);
        lightVertexVector_0.z=dot(lvct,tangentSpaceNormal);

            // translate the light 1 vector

        lvct=light_1.position.xyz-vtx;
        lightDistance_1=length(lvct);

        lightVertexVector_1.x=dot(lvct,tangentSpaceTangent);
        lightVertexVector_1.y=dot(lvct,tangentSpaceBinormal);
        lightVertexVector_1.z=dot(lvct,tangentSpaceNormal);

            // translate the light 2 vector

        lvct=light_2.position.xyz-vtx;
        lightDistance_2=length(lvct);

        lightVertexVector_2.x=dot(lvct,tangentSpaceTangent);
        lightVertexVector_2.y=dot(lvct,tangentSpaceBinormal);
        lightVertexVector_2.z=dot(lvct,tangentSpaceNormal);

            // translate the light 3 vector

        lvct=light_3.position.xyz-vtx;
        lightDistance_3=length(lvct);

        lightVertexVector_3.x=dot(lvct,tangentSpaceTangent);
        lightVertexVector_3.y=dot(lvct,tangentSpaceBinormal);
        lightVertexVector_3.z=dot(lvct,tangentSpaceNormal);

            // the varying uv

        fragUV=vertexUV;
    }
</script>

<script id="wsModelFragShader" type="x-shader/x-fragment">
    uniform lowp sampler2D baseTex;
    uniform lowp sampler2D normalTex;
    uniform lowp sampler2D specularTex;

    uniform lowp vec3 ambient;
    uniform mediump float shineFactor;

    struct lightType {
        highp vec4 position;
        lowp vec4 color;
        mediump float intensity;
        mediump float invertIntensity;
        mediump float exponent;
    };

    uniform lightType light_0;
    uniform lightType light_1;
    uniform lightType light_2;
    uniform lightType light_3;

    varying highp vec3 eyeVector;
    varying highp vec2 fragUV;

    varying highp float lightDistance_0;
    varying highp float lightDistance_1;
    varying highp float lightDistance_2;
    varying highp float lightDistance_3;

    varying highp vec3 lightVertexVector_0;
    varying highp vec3 lightVertexVector_1;
    varying highp vec3 lightVertexVector_2;
    varying highp vec3 lightVertexVector_3;

    void main(void)
    {
        lowp float att;

            // the ambient

        lowp vec3 pixelAmbient=ambient;

            // the texture fragment

        lowp vec4 tex=texture2D(baseTex,fragUV);

            // the starting bump map
            // since it will be created by going through the
            // lights, we need a default value

        highp vec3 bumpLightVertexVector;
        lowp vec3 bumpMap=normalize((texture2D(normalTex,fragUV.xy).rgb*2.0)-1.0);
        lowp float bump=dot(vec3(0.33,0.33,0.33),bumpMap);

            // the starting spec map

        lowp vec3 spec=vec3(0.0,0.0,0.0),specHalfVector;
        lowp vec3 specMap=texture2D(specularTex,fragUV.xy).rgb;
        lowp float specFactor;

            // light 0

        if (lightDistance_0<light_0.intensity) {

                // the lighting attenuation

            att=1.0-(lightDistance_0*light_0.invertIntensity);
            att+=pow(att,light_0.exponent);
            pixelAmbient+=(light_0.color.rgb*att);

                // per-light bump calc

            bumpLightVertexVector=normalize(lightVertexVector_0);
            bump+=(dot(bumpLightVertexVector,bumpMap)*att);

                // per-light spec count

            specHalfVector=normalize(normalize(eyeVector)+bumpLightVertexVector);
            specFactor=max(dot(bumpMap,specHalfVector),0.0);
            spec+=((specMap*pow(specFactor,shineFactor))*att);
        }

            // light 1

        if (lightDistance_1<light_1.intensity) {

                // the lighting attenuation

            att=1.0-(lightDistance_1*light_1.invertIntensity);
            att+=pow(att,light_1.exponent);
            pixelAmbient+=(light_1.color.rgb*att);

                // per-light bump calc

            bumpLightVertexVector=normalize(lightVertexVector_1);
            bump+=(dot(bumpLightVertexVector,bumpMap)*att);

                // per-light spec count

            specHalfVector=normalize(normalize(eyeVector)+bumpLightVertexVector);
            specFactor=max(dot(bumpMap,specHalfVector),0.0);
            spec+=((specMap*pow(specFactor,shineFactor))*att);
        }

            // light 2

        if (lightDistance_2<light_2.intensity) {

                // the lighting attenuation

            att=1.0-(lightDistance_2*light_2.invertIntensity);
            att+=pow(att,light_2.exponent);
            pixelAmbient+=(light_2.color.rgb*att);

                // per-light bump calc

            bumpLightVertexVector=normalize(lightVertexVector_2);
            bump+=(dot(bumpLightVertexVector,bumpMap)*att);

                // per-light spec count

            specHalfVector=normalize(normalize(eyeVector)+bumpLightVertexVector);
            specFactor=max(dot(bumpMap,specHalfVector),0.0);
            spec+=((specMap*pow(specFactor,shineFactor))*att);
        }

            // light 3

        if (lightDistance_3<light_3.intensity) {

                // the lighting attenuation

            att=1.0-(lightDistance_3*light_3.invertIntensity);
            att+=pow(att,light_3.exponent);
            pixelAmbient+=(light_3.color.rgb*att);

                // per-light bump calc

            bumpLightVertexVector=normalize(lightVertexVector_3);
            bump+=(dot(bumpLightVertexVector,bumpMap)*att);

                // per-light spec count

            specHalfVector=normalize(normalize(eyeVector)+bumpLightVertexVector);
            specFactor=max(dot(bumpMap,specHalfVector),0.0);
            spec+=((specMap*pow(specFactor,shineFactor))*att);
        }

            // finish the spec by making sure
            // it's dimmed in dark areas

        spec=min(spec,1.0)*((pixelAmbient.r+pixelAmbient.g+pixelAmbient.b)*0.33);

            // add bump into the ambient and make
            // sure it's never less than 10% of the
            // ambient

        pixelAmbient=max((pixelAmbient*bump),(ambient*0.9));

            // finally create the pixel

        gl_FragColor.rgb=(tex.rgb*pixelAmbient)+spec;
        gl_FragColor.a=tex.a;
    }
</script>

<script id="wsTextVertShader" type="x-shader/x-vertex">    
    attribute highp vec3 vertexPosition;
    attribute highp vec2 vertexUV;

    uniform highp mat4 orthoMatrix;

    varying highp vec2 fragUV;

    void main(void)
    {
        gl_Position=orthoMatrix*vec4(vertexPosition,1.0);
        fragUV=vertexUV;
    }
</script>

<script id="wsTextFragShader" type="x-shader/x-fragment">
    uniform lowp sampler2D baseTex;
    uniform lowp vec3 color;

    varying highp vec2 fragUV;

    void main(void)
    {
        lowp vec4 tex=texture2D(baseTex,fragUV);

        gl_FragColor.rgb=color;       // treat as gray scale, use that for alpha, fill rest with color
        gl_FragColor.a=tex.r;
    }
</script>

<script id="wsInterfaceVertShader" type="x-shader/x-vertex">    
    attribute highp vec3 vertexPosition;

    uniform highp mat4 orthoMatrix;

    void main(void)
    {
        gl_Position=orthoMatrix*vec4(vertexPosition,1.0);
    }
</script>

<script id="wsInterfaceFragShader" type="x-shader/x-fragment">
    uniform lowp vec3 color;

    void main(void)
    {
        gl_FragColor.rgb=color;
        gl_FragColor.a=1.0;
    }
</script>

<script id="wsDebugVertShader" type="x-shader/x-vertex">    
    attribute highp vec3 vertexPosition;

    uniform highp mat4 perspectiveMatrix;
    uniform highp mat4 modelMatrix;

    void main(void)
    {
        gl_Position=perspectiveMatrix*modelMatrix*vec4(vertexPosition,1.0);
    }
</script>

<script id="wsDebugFragShader" type="x-shader/x-fragment">
    uniform lowp vec3 color;
        
    void main(void)
    {
        gl_FragColor.rgb=color;
        gl_FragColor.a=1.0;
    }
</script>

</head>

<!-- the body -->

<body onload="wsInit()">
    
<!-- the drawing canvas -->

<canvas id="wsCanvas" style="position:absolute;left:0px;top:0px;border:1px solid black" width="1024" height="576"></canvas>

<!-- link back -->

<div style="position:absolute;left:2px;top:590px;width:200px;font-family:arial;font-size:16px;white-space:nowrap">
    <a href="http://klinksoftware.net/forum/index.php">Klink! Software Forum</a> - <a href="https://github.com/ggadwa/WSJS">GitHub Source Code</a>
</div>

</body>
</html>
